\chapter{编程日志}
2015.7.31

从今天开始，记录编程中值得记录的错误，提醒以后。

编程数值计算时，一定要注意初始化数据。当计算结果飘了，很可能是数据没有初始化导致数值累加。

最近做计算，输出结果一直为0，折腾了好几天。也由于是新编程序，担心是算法问题，各种核查很多遍，虽然侧面加深了对理论的理解，但是最终问题却跟这无关。原来是最后一步的fortran矩阵运算，matmul(um,rho1)，习惯的写成了，um*rho1，导致输出为0。用的是 Intel的fortran编译器，这样的错误居然没报错，也是无语。知道Intel的fortran语法较宽松，可是这样太宽松了。所以啊，以后为了防止这类错误，还是用语法较为严格的 gfortran也编译看看吧。

2015.8.1

今天用 Intel fortran 编译程序，弹出来说许可证过期了，不能用了。哎～ 我都忘记这碴了！习惯了不为软件付费，来个这个还真不习惯。算了，以后还是用 gfortran 吧。

经常遇到如下错误：

Program received signal SIGSEGV: Segmentation fault - invalid memory reference.

一般就是数组下标过界了，一定要注意组元的赋值。

2015.8.6

Intel fortran 编译器许可证过期是个教训。不同编译器，要求不同，Intel fortran 编译器要求松些，直接导致改用 gfortran 编译器出现很多警告和计算错误。所以以后编程一定要保证这两个编译器都通过和计算一致。

商业软件就是商业软件，Intel fortran 足足比开源免费的 gfortran 快个 6 倍。




\chapter{Python}
\section{准备工作}
\subsection{安装模块}
首先安装python的模块管理器，对于python2，有\verb|sudo apt-get install python-pip|；对于python3，有\verb|sudo apt-get install python3-pip|。

安装模块，以pylab为例。对于python2，有\verb|sudo pip install pylab|；对于python3，有\verb|sudo pip3 install pylab|。

\verb|sudo apt-get install python-matplotlib|



\subsection{Ubuntu切换Python3}
因为Ubuntu很多底层采用的是Python2.*，Python3和Python2是互相不兼容的，所以此时不能卸载Python2。要使用python3.*，可以直接输入命令python3即可。输入python默认是python2.*。



\subsection{Python脚本编码设置}
在文件开头加入 \# -*- coding: UTF-8 -*- 或者 \#coding=utf-8可以设置Python脚本编码。


\subsection{设置脚本解释器的版本}
``\#!''是脚本中的约定符号，用来指定解释器的版本。
\begin{itemize}
\item 直接指定解释器路径，如：\verb|#!/usr/bin/python|、\verb|#!/usr/bin/python2.7|、
或\verb|#!/usr/bin/python3.4|

\item 通过env命令来指定解释器，如：\\

\verb|#!/usr/bin/env python|

由于在Ubuntu中Shell输入python默认调用的是python2.*，所以这是指定解释器为python2.*类版本。又如

\verb|#!/usr/bin/env python3|

由于python存在python2.*和python3.*两类版本而不兼容，所有这是指定解释器为python3.*类版本。
\end{itemize}



\subsection{脚本的执行}
对于脚本语言，执行方法都类似。类似于Shell脚本的执行一样，Python脚本的执行也有两种方法。

（1）作为解释器参数，即直接运行解释器，其参数就是Shell脚本的文件名，例如

使用Python2.*解释：
\verb|python test.py|\qquad 或更严格的 \qquad \verb|/usr/bin/python2.7 test.py|

使用Python3.*解释：
\verb|python3 test.py|\qquad 或更严格的 \qquad \verb|/usr/bin/python3.4 test.py|

这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。

（2）作为可执行程序。

（a）在脚本所在目录下，首先使脚本具有执行权限，有两种方法：
\begin{enumerate}
\item 命令操作：\verb|chmod +x ./test.py|；
\item 图形化操作：选中脚本test.py右键勾选可以执行选项。
\end{enumerate}

（b）然后执行程序：\verb|./test.py|

注意，一定要写成./test.py，而不是test.py。这里的“./”实质指的是相对路径，即当前路径下。如果test.py在/bin目录下，当然也可以采用绝大路径来运行即“/bin/test.py”，只不过相对路径更简便些。运行其它二进制的程序也一样，直接写test.py，Linux系统会去PATH里寻找有没有叫test.py的，而只有/bin、 /sbin、 /usr/bin、/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.py是会找不到命令的，要用./test.py告诉系统说，就在当前目录找。这意味着如果你编的程序经常用，那么可以添加到系统路径中，这样就真可以直接运行了。

通过这种方式运行的脚本，第一行一定要写对，好让系统查找到正确的解释器。

这里的"系统"，其实就是shell这个应用程序，但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。



\section{Python2.*与Python3.*的主要变化}
Python的3​​.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。

为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。

新的Python程序建议使用Python 3.0版本的语法。除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。

大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6，Python 2.7来执行。


\subsection{print语句改成print()函数}
print语句没有了，取而代之的是print()函数。 Python 2.6与Python 2.7部分地支持这种形式的print语法。在Python 2.6与Python 2.7里面，以下三种形式是等价的：
\begin{lstlisting}[language=Python]
print "fish"
print ("fish") #注意print后面有个空格
print("fish") #print()不能带有任何其它参数
\end{lstlisting}



\subsection{TypeError: `str' does not support the buffer interface}
%http://blog.csdn.net/chuanchuan608/article/details/17915959
 Python 3中套接字编程中遇到TypeError: `str' does not support the buffer interface的解决办法。

In python 3, bytes strings and unicodestrings are now two different types. Since sockets are not aware of string encodings, they are using raw bytes strings, that have a slightly differentinterface from unicode strings.
So, now, whenever you have a unicode stringthat you need to use as a byte string, you need toencode() it. And whenyou have a byte string, you need to decode it to use it as a regular(python 2.x) string.
Unicode strings are quotes enclosedstrings. Bytes strings are b"" enclosed strings




\section{基本语法}
\subsection{注释}
python注释采用 \# 开头，没有块注释。



\subsection{标识符}
\begin{itemize}
\item 标识符由字母、数字、下划线组成；

\item 所有标识符可以包括英文、数字以及下划线（\_），但不能以数字开头；

\item 标识符区分大小写；

\item 以下划线开头的标识符有特殊意义。以单下划线开头（\_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用``from xxx import *"而导入；

\item 以双下划线开头的（\_\_foo）代表类的私有成员；以双下划线开头和结尾的（\_\_foo\_\_）代表python里特殊方法专用的标识，如\_\_init\_\_()代表类的构造函数。
\end{itemize}



\subsection{保留字符}
Python中的保留字不能用作常数或变数，或任何其他标识符名称，所有Python的关键字只包含小写字母。
Python的保留字有：and、exec、not、assert、finally、or、break、for、pass、class、from、print、continue、global、
raise、def、if、return、del、import、try、elif、in、while、else、is、with、except、lambda、	yield




\subsection{缩进}
Python与其他语言最大的区别就是，Python的代码块不使用大括号（\{\}）来控制类，函数以及其他逻辑判断。Python最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行，一般缩进4个空格。如下所示：
\begin{lstlisting}[language=Python]
if True:
    print "True"
else:
    print "False"
\end{lstlisting}
以下代码将会执行错误：
\begin{lstlisting}[language=Python]
     if True:
    print "Answer"
    print "True"
else:
    print "Answer"
  print "False"
\end{lstlisting}



\subsection{多行语句}
Python语句中一般以新行作为为语句的结束符。

但是我们可以使用斜杠（ \verb|\|）将一行的语句分为多行显示，如下所示：
\begin{lstlisting}[language=Python]
 total = item_one + \ 
        item_two + \
        item_three
\end{lstlisting}

语句中包含[], \{\} 或 () 括号就不需要使用多行连接符。如下实例：
\begin{lstlisting}[language=Python]
days = ['Monday', 'Tuesday', 'Wednesday',
        'Thursday', 'Friday']
\end{lstlisting}



\subsection{引号}
Python 接收单引号(' )，双引号(" )，三引号(''' """) 来表示字符串，引号的开始与结束必须的相同类型的。

其中三引号可以由多行组成，编写多行文本的快捷语法，常用语文档字符串，在文件的特定地点，被当做注释。
\begin{lstlisting}[language=Python]
word = 'word'
sentence = "This is a sentence."
paragraph = """This is a paragraph. It is
made up of multiple lines and sentences."""
\end{lstlisting}



\subsection{空行}
函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。

空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。

记住：空行也是程序代码的一部分。



\subsection{同一行显示多条语句}
Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：
\begin{lstlisting}[language=Python]
import sys; x = 'foo'; sys.stdout.write(x + '\n')
\end{lstlisting}



\subsection{多个语句构成代码组}
缩进相同的一组语句构成一个代码块，我们称之代码组。像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。我们将首行及后面的代码组称为一个子句(clause)。如下实例：
\begin{lstlisting}[language=Python]
if expression : 
    suite 
elif expression :  
    suite  
else :  
    suite 
\end{lstlisting}



\section{变量赋值}
变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。

Python中的变量不需要声明，变量的赋值操作既是变量声明和定义的过程。
每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。
每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。
等号（=）用来给变量赋值，等号（=）运算符左边是一个变量名，等号（=）运算符右边是存储在变量中的值。例如：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

counter = 100 # 赋值整型变量
miles = 1000.0 # 浮点型
name = "John" # 字符串

print counter
print miles
print name
\end{lstlisting}
以上实例中，100，1000.0和"John"分别赋值给counter，miles，name变量。执行以上程序会输出如下结果：
\begin{lstlisting}[language=Python]
100
1000.0
John
\end{lstlisting}

Python也允许同时为多个变量赋值。例如：
\begin{lstlisting}[language=Python]
a = b = c = 1
\end{lstlisting}
以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。

可以为多个对象指定多个变量。例如：
\begin{lstlisting}[language=Python]
a, b, c = 1, 2, "john"
\end{lstlisting}
以上实例，两个整型对象1和2的分配给变量a和b，字符串对象"john"分配给变量c。



\section{标准数据类型}
Python有五个标准的数据类型：
\begin{itemize}
\item Numbers（数字）
\item String（字符串）
\item List（列表）
\item Tuple（元组）
\item Dictionary（字典）
\end{itemize}


\subsection{数字}
数字数据类型用于存储数值。Python支持四种不同的数值类型：
\begin{itemize}
\item int（有符号整型）
\item long（长整型[也可以代表八进制和十六进制]）
\item float（浮点型）
\item complex（复数）
\end{itemize}

具体使用注意事项：
\begin{itemize}
\item Python使用"L"来显示长整型，如：535633629843L。长整型也可以使用小写"L"，但是还是建议您使用大写"L"，避免与数字"1"混淆；

\item 浮点型可以用科学表示，如：2.1e+3表示$2.1\times 10^3=2100.0$、2.1e-3表示$2.1\times 10^{-3}=0.0021$，也可以用大写的E；

\item 复数由实数部分和虚数部分构成，可以用a + bj或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型，也可以用大写的J。
\end{itemize}


\subsection{字符串}
字符串或串(String)是由数字、字母、下划线组成的一串字符。一般记为 :
\begin{lstlisting}[language=Python]
s="a1a2···an"(n>=0)
\end{lstlisting}
它是编程语言中表示文本的数据类型。

python的字串列表有2种取值顺序：
\begin{itemize}
\item 从左到右索引默认0开始的，最大范围是字符串长度少1
\item 从右到左索引默认-1开始的，最大范围是字符串开头
\end{itemize}
如果你的实要取得一段子串的话，可以用到变量[头下标:尾下标]，就可以截取相应的字符串，其中下标是从0开始算起，可以是正数或负数，下标可以为空表示取到头或尾。比如:
\begin{lstlisting}[language=Python]
s = 'ilovepython'
\end{lstlisting}
s[1:5]的结果是love。当使用以冒号分隔的字符串，python返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。上面的结果包含了s[1]的值l，而取到的最大范围不包括上边界，就是s[5]的值p。

加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

str = 'Hello World!'

print str # 输出完整字符串
print str[0] # 输出字符串中的第一个字符
print str[2:5] # 输出字符串中第三个至第五个之间的字符串
print str[2:] # 输出从第三个字符开始的字符串
print str * 2 # 输出字符串两次
print str + "TEST" # 输出连接的字符串
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
Hello World!
H
llo
llo World!
Hello World!Hello World!
Hello World!TEST
\end{lstlisting}


\subsubsection{转义字符}
在需要在字符中使用特殊字符时，python用反斜杠(\verb|\|)转义字符。如下表：

\begin{tabular}{l|l}
转义字符&	描述\\
\verb|\| (在行尾时)&	续行符\\
\verb|\\|	&反斜杠符号\\
\verb|\'|	&单引号\\
\verb|\"|	&双引号\\
\verb|\a|	&响铃\\
\verb|\b|	&退格(Backspace)\\
\verb|\e|	&转义\\
\verb|\000|	&空\\
\verb|\n|	&换行\\
\verb|\v|	&纵向制表符\\
\verb|\t|	&横向制表符\\
\verb|\r|	&回车\\
\verb|\f|	&换页\\
\verb|\oyy|	&八进制数，yy代表的字符，例如：\verb|\o12|代表换行\\
\verb|\xyy|	&十六进制数，yy代表的字符，例如：\verb|\x0a|代表换行\\
\verb|\other|	&其它的字符以普通格式输出
\end{tabular}


\subsubsection{字符串运算符}
下表实例变量a值为字符串"Hello"，b变量值为"Python"：

\begin{itemize}
\item 操作符;	描述;	实例
\item +	;字符串连接;	a + b 输出结果： HelloPython
\item *;	重复输出字符串;	a*2 输出结果：HelloHello
\item \verb|[]|	; 通过索引获取字符串中字符;	a[1] 输出结果 e
\item \verb|[ : ]|; 	截取字符串中的一部分	a[1:4] 输出结果 ell
\item in;	成员运算符 - 如果字符串中包含给定的字符返回 True;	H in a 输出结果 1
\item not in;	成员运算符 - 如果字符串中不包含给定的字符返回 True;	M not in a 输出结果 1
\item r/R;	原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母"r"（可以大小写）以外，与普通字符串有着几乎完全相同的语法。;	\verb|print r'\n' prints \n| 和 \verb|print R'\n' prints \n|
\end{itemize}



\subsubsection{三引号——字符串的抄录}
python中三引号可以将复杂的字符串进行抄录，即python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。
\begin{lstlisting}[language=Python]
>>> hi = '''hi 
... there'''
>>> hi
'hi \nthere'
>>> print(hi)
hi 
there
>>> 
\end{lstlisting}

三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。


\subsubsection{Unicode 字符串}
Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单：
\begin{lstlisting}[language=Python]
>>> u'Hello World !'
u'Hello World !'
\end{lstlisting}

引号前小写的"u"表示这里创建的是一个 Unicode 字符串。如果你想加入一个特殊字符，可以使用 Python 的 Unicode-Escape 编码。如下例所示：
\begin{lstlisting}[language=Python]
>>> u'Hello\u0020World !'
u'Hello World !'
\end{lstlisting}
被替换的 \u0020 标识表示在给定位置插入编码值为 0x0020 的 Unicode 字符（空格符）。


\subsubsection{字符串内建函数}
 以下实例展示了capitalize()方法的实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

str = "this is string example....wow!!!";

print "str.capitalize() : ", str.capitalize()
\end{lstlisting}
输出结果如下：
\begin{lstlisting}[language=Python]
str.capitalize() :  This is string example....wow!!!
\end{lstlisting}


\subsection{列表}
List（列表） 是 Python 中使用最频繁的数据类型。
列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。
列表用[ ]标识。是python最通用的复合数据类型。
列表中的值得分割也可以用到变量[头下标:尾下标]，就可以截取相应的列表，从左到右索引默认0开始的，从右到左索引默认-1开始，下标可以为空表示取到头或尾。
加号（+）是列表连接运算符，星号（*）是重复操作。
如下实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']

print list # 输出完整列表
print list[0] # 输出列表的第一个元素
print list[1:3] # 输出第二个至第三个的元素 
print list[2:] # 输出从第三个开始至列表末尾的所有元素
print tinylist * 2 # 输出列表两次
print list + tinylist # 打印组合的列表
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
['abcd', 786, 2.23, 'john', 70.2]
abcd
[786, 2.23]
[2.23, 'john', 70.2]
[123, 'john', 123, 'john']
['abcd', 786, 2.23, 'john', 70.2, 123, 'john']
\end{lstlisting}


\subsubsection{更新列表}
可以对列表的数据项进行修改或更新，也可以使用append()方法来添加列表项，如下所示：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

list = ['physics', 'chemistry', 1997, 2000];

print "Value available at index 2 : "
print list[2];
list[2] = 2001;
print "New value available at index 2 : "
print list[2];
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
Value available at index 2 :
1997
New value available at index 2 :
2001
\end{lstlisting}


\subsubsection{删除列表元素}
可以使用 del 语句来删除列表的的元素，如下实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

list1 = ['physics', 'chemistry', 1997, 2000];

print list1;
del list1[2];
print "After deleting value at index 2 : "
print list1;
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
['physics', 'chemistry', 1997, 2000]
After deleting value at index 2 :
['physics', 'chemistry', 2000]
\end{lstlisting}


\subsubsection{列表操作符}
列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。
如下所示：

\begin{tabular}{l|l|l}
表达式&	结果&	描述\\
\verb|len([1, 2, 3])|&	3&	长度\\
\verb|[1, 2, 3] + [4, 5, 6]|&	\verb|[1, 2, 3, 4, 5, 6]|&	组合\\
\verb|['Hi!'] * 4| &	\verb|['Hi!', 'Hi!', 'Hi!', 'Hi!']| &	重复\\
\verb|3 in [1, 2, 3]| &	True&	元素是否存在于列表中\\
\verb|for x in [1, 2, 3]: print x| &	1 2 3&	迭代
\end{tabular}


\subsubsection{列表截取}
Python的列表截取与字符串操作类型，如下所示：
\begin{lstlisting}[language=Python]
L = ['spam', 'Spam', 'SPAM!']
\end{lstlisting}
操作：

\begin{tabular}{l|l|l}
表达式&	结果&	描述\\
L[2]&	'SPAM!'	&读取列表中第三个元素\\
L[-2]&	'Spam'	&读取列表中倒数第二个元素\\
L[1:]&	['Spam', 'SPAM!']&	从第二个元素开始截取列表
\end{tabular}


\subsubsection{列表内置函数}
\begin{itemize}
\item cmp(list1, list2)：
比较两个列表的元素
\item	len(list)：
列表元素个数
\item	max(list)：
返回列表元素最大值
\item	min(list)：
返回列表元素最小值
\item	list(seq)：
将元组转换为列表
\end{itemize}


\subsubsection{列表方法}
\begin{itemize}
\item list.append(obj) ：在列表末尾添加新的对象

\item list.count(obj)：统计某个元素在列表中出现的次数

\item list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）

\item list.index(obj)：从列表中找出某个值第一个匹配项的索引位置

\item list.insert(index, obj)：将对象插入列表

\item list.pop(obj=list[-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值

\item list.remove(obj)：移除列表中某个值的第一个匹配项

\item list.reverse()：反向列表中元素

\item list.sort([func])：对原列表进行排序
\end{itemize}







\subsection{元组}
Tuple（元组）是另一个数据类型，类似于List（列表）。
元组用"()"标识。内部元素用逗号隔开。但是元素不能二次赋值，相当于只读列表。
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 )
tinytuple = (123, 'john')

print tuple # 输出完整元组
print tuple[0] # 输出元组的第一个元素
print tuple[1:3] # 输出第二个至第三个的元素 
print tuple[2:] # 输出从第三个开始至列表末尾的所有元素
print tinytuple * 2 # 输出元组两次
print tuple + tinytuple # 打印组合的元组
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
('abcd', 786, 2.23, 'john', 70.2)
abcd
(786, 2.23)
(2.23, 'john', 70.2)
(123, 'john', 123, 'john')
('abcd', 786, 2.23, 'john', 70.2, 123, 'john')
\end{lstlisting}
以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 )
list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
#tuple[2] = 1000 # 元组中是非法应用
list[2] = 1000 # 列表中是合法应用
\end{lstlisting}


\subsubsection{连接元组}
元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

tup1 = (12, 34.56);
tup2 = ('abc', 'xyz');

# 以下修改元组元素操作是非法的。
# tup1[0] = 100;

# 创建一个新的元组
tup3 = tup1 + tup2;
print tup3;
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
(12, 34.56, 'abc', 'xyz')
\end{lstlisting}


\subsubsection{删除元组}
元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:
\begin{lstlisting}[language=Python]
#!/usr/bin/python

tup = ('physics', 'chemistry', 1997, 2000);

print tup;
del tup;
print "After deleting tup : "
print tup;
\end{lstlisting}
以上实例元组被删除后，输出变量会有异常信息，输出如下所示：
\begin{lstlisting}[language=Python]
('physics', 'chemistry', 1997, 2000)
After deleting tup :
Traceback (most recent call last):
  File "test.py", line 9, in <module>
    print tup;
NameError: name 'tup' is not defined
\end{lstlisting}


\subsubsection{元组运算符}
与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。

\begin{tabular}{l|l|l}
表达式&	结果&	描述\\
\verb|len((1, 2, 3))|&	3	&计算元素个数\\
\verb|(1, 2, 3) + (4, 5, 6)|	&\verb|(1, 2, 3, 4, 5, 6)|&	连接\\
\verb|['Hi!'] * 4|	&\verb|['Hi!', 'Hi!', 'Hi!', 'Hi!']| &	复制\\
\verb|3 in (1, 2, 3)|&	True&	元素是否存在\\
\verb|for x in (1, 2, 3): print x| &	1 2 3	&迭代
\end{tabular}


\subsubsection{元组索引、截取}
因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：

元组：\verb|L = ('spam', 'Spam', 'SPAM!')|

\begin{tabular}{l|l|l}
 表达式 & 	结果&	描述\\
\verb|L[2]| &	\verb|'SPAM!'| &	读取第三个元素\\
\verb|L[-2]| &	\verb|'Spam'|	 &反向读取；读取倒数第二个元素\\
\verb|L[1:]| &	\verb|('Spam', 'SPAM!')| &	截取元素
\end{tabular}


\subsubsection{无关闭分隔符}
任意无符号的对象，以逗号隔开，默认为元组，如下实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

print 'abc', -4.24e93, 18+6.6j, 'xyz';
x, y = 1, 2;
print "Value of x , y : ", x,y;
\end{lstlisting}
以上实例允许结果：
\begin{lstlisting}[language=Python]
abc -4.24e+93 (18+6.6j) xyz
Value of x , y : 1 2
\end{lstlisting}


\subsubsection{元组内置函数}
Python元组包含了以下内置函数：
\begin{itemize}
\item 	cmp(tuple1, tuple2)：比较两个元组元素。
\item	len(tuple)：计算元组元素个数。
\item	max(tuple)：返回元组中元素最大值。
\item	min(tuple)：返回元组中元素最小值。
\item	tuple(seq)：将列表转换为元组。
\end{itemize}


\subsection{字典}
字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用"\{ \}"标识。字典由索引(key)和它对应的值value组成。如下示例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

dict = {}
dict['one'] = "This is one"
dict[2] = "This is two"

tinydict = {'name': 'john','code':6734, 'dept': 'sales'}


print dict['one'] # 输出键为'one' 的值
print dict[2] # 输出键为 2 的值
print tinydict # 输出完整的字典
print tinydict.keys() # 输出所有键
print tinydict.values() # 输出所有值
\end{lstlisting}
输出结果为：
\begin{lstlisting}[language=Python]
This is one
This is two
{'code': 6734, 'name': 'john', 'dept': 'sales'}
dict_keys(['code', 'name', 'dept'])
dict_values([6734, 'john', 'sales'])
\end{lstlisting}


\subsubsection{字典键的特性}
字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。

两个重要的点需要记住：

1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python
 
dict = {'Name': 'Zara', 'Age': 7, 'Name': 'Manni'};
 
print "dict['Name']: ", dict['Name'];
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
dict['Name']:  Manni
\end{lstlisting}

2）键必须不可变，所以可以用数，字符串或元组充当，所以用列表就不行，如下实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python
 
dict = {['Name']: 'Zara', 'Age': 7};
 
print "dict['Name']: ", dict['Name'];
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    dict = {['Name']: 'Zara', 'Age': 7};
TypeError: list objects are unhashable
\end{lstlisting}



\subsubsection{修改字典}
向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:
\begin{lstlisting}[language=Python]
#!/usr/bin/python
 
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'};
 
dict['Age'] = 8; # update existing entry
dict['School'] = "DPS School"; # Add new entry
 
 
print "dict['Age']: ", dict['Age'];
print "dict['School']: ", dict['School'];
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
dict['Age']:  8
dict['School']:  DPS School
\end{lstlisting}


\subsubsection{删除字典}
能删单一的元素也能清空字典，清空只需一项操作。

显示删除一个字典用del命令，如下实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'};
 
del dict['Name']; # 删除键是'Name'的条目
dict.clear();     # 清空词典所有条目
del dict ;        # 删除词典
 
print "dict['Age']: ", dict['Age'];
print "dict['School']: ", dict['School'];
\end{lstlisting}
但这会引发一个异常，因为用del后字典不再存在：
\begin{lstlisting}[language=Python]
dict['Age']:
Traceback (most recent call last):
  File "test.py", line 8, in <module>
    print "dict['Age']: ", dict['Age'];
TypeError: 'type' object is unsubscriptable
\end{lstlisting}


\subsubsection{字典内置函数\&方法}
Python字典包含了以下内置函数：
\begin{itemize}
\item 	cmp(dict1, dict2)
比较两个字典元素。
\item len(dict)
计算字典元素个数，即键的总数。
\item	str(dict)
输出字典可打印的字符串表示。
\item	type(variable)
返回输入的变量类型，如果变量是字典就返回字典类型。
\end{itemize}


Python字典包含了以下内置方法：
\begin{itemize}
\item 	radiansdict.clear()
删除字典内所有元素
\item	radiansdict.copy()
返回一个字典的浅复制
\item	radiansdict.fromkeys()
创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
\item	radiansdict.get(key, default=None)
返回指定键的值，如果值不在字典中返回default值
\item	radiansdict.has\_key(key)
如果键在字典dict里返回true，否则返回false
\item	radiansdict.items()
以列表返回可遍历的(键, 值) 元组数组
\item	radiansdict.keys()
以列表返回一个字典所有的键
\item	radiansdict.setdefault(key, default=None)
和get()类似, 但如果键不已经存在于字典中，将会添加键并将值设为default
\item	radiansdict.update(dict2)
把字典dict2的键/值对更新到dict里
\item	radiansdict.values()
以列表返回字典中的所有值
\end{itemize}






\subsection{数据类型转换}
数据类型的转换只需要将数据类型作为函数名即可。以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。
\begin{itemize}
\item int(x [,base])：将x转换为一个整数

\item long(x [,base] )：将x转换为一个长整数

\item float(x)：将x转换到一个浮点数

\item complex(real [,imag])：创建一个复数

\item str(x)：将对象 x 转换为字符串

\item repr(x)：将对象 x 转换为表达式字符串

\item eval(str)：用来计算在字符串中的有效Python表达式,并返回一个对象

\item tuple(s)：将序列 s 转换为一个元组

\item list(s)：将序列 s 转换为一个列表

\item set(s)：转换为可变集合

\item dict(d)：创建一个字典。d 必须是一个序列 (key,value)元组。

\item frozenset(s)：转换为不可变集合

\item chr(x)：将一个整数转换为一个字符

\item unichr(x)：将一个整数转换为Unicode字符

\item ord(x)：将一个字符转换为它的整数值

\item hex(x)：将一个整数转换为一个十六进制字符串

\item oct(x)：将一个整数转换为一个八进制字符串
\end{itemize}



\subsubsection{不同类型的数字}
对于初学者，各种不同的数值类型令人迷惑。请看下面4 个不同的值：5、5.0、'5'和'5.0'。虽然它们看起来相似，但内部表示截然不同。

5 是一个整数，可直接用于算术运算。5.0 是一个浮点数，也可用于算术运算，但包含小数部分。

'5' 和'5.0' 都是字符串，分别包含1个和3 个字符。字符串可显示到屏幕上或用于基于字符的操作（如删除空白或计算字符数）。字符串不能用于算术运算。当然，字符串可用于拼接，虽然结果可能让人觉得有点不合情理。例如：
\begin{lstlisting}[language=Python]
>>> 3 * '5'
'555'
>>> 3 * '5.0'
'5.05.05.0'
\end{lstlisting}



\section{输入与输出}
\subsection{读取键盘输入}
Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：
\begin{itemize}
\item \verb|raw_input()|
\item \verb|input()|
\end{itemize}


\subsubsection{raw\_input函数}
\verb|raw_input([prompt])| 函数从标准输入读取一个行，并返回一个字符串，按「Enter」完成输入：
\begin{lstlisting}[language=Python]
#!/usr/bin/python
 
str = raw_input("Enter your input: ");
print "Received input is : ", str
\end{lstlisting}
这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入"Hello Python！"，它的输出如下：
\begin{lstlisting}[language=Python]
Enter your input: Hello Python!
Received input is :  Hello Python!
\end{lstlisting}


\subsubsection{input() 函数}
input([prompt]) 函数和raw\_input([prompt]) 函数基本可以互换，但是input会假设输入是一个有效的Python表达式，并返回运算结果。例如：
\begin{lstlisting}[language=Python]
#!/usr/bin/python
 
str = input("Enter your input: ");
print "Received input is : ", str
\end{lstlisting}
这会产生如下的对应着输入的结果：
\begin{lstlisting}[language=Python]
Enter your input: [x*5 for x in range(2,10,2)]
Recieved input is :  [10, 20, 30, 40]
\end{lstlisting}


\subsubsection{返回值的算术运算}
由于函数input()只是返回字符串，因此如果需要的是数字（如用于算术运算），就必须使用Python 的数值转换函数。例如，请看下面的程序：
\begin{lstlisting}[language=Python]
age = input('How old are you today? ')
age10 = int(age) + 10
print('In 10 years you will be ' +  str(age10) + ' years old.')
\end{lstlisting}
假设运行该程序时用户输入22，变量age 将指向字符串'22'，因为Python 不会自动将看起来像数字的字符串转换为整数或浮点数。如果要将字符串用于算术运算，必须先将其转换为数字。为此，可使用函数int(s)（如果需要的是整数）或float(s)（如果需要的是浮点数）。

这里要指出的最后一个技巧是，在print 语句中，必须将变量age10（它指向一个整数） 转换为字符串，这样才能打印它。如果忘记这样做，Python 将显示错误消息，指出不能将数字与字符串相加。


\subsection{输出}
在Python2.*中，输出是print语句；而在Python3.*中输出是print()函数。这在Python2.*和Python3.*区别章节中有相关说明。这里按照Python3.*的标准来说明。

用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出\verb|'hello, world'|，用代码实现如下：
\begin{lstlisting}[language=Python]
print('hello, world')
\end{lstlisting}
print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：
\begin{lstlisting}[language=Python]
 print('The quick brown fox', 'jumps over', 'the lazy dog')
\end{lstlisting}
print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：

\verb|The quick brown fox jumps over the lazy dog|

print()也可以打印整数，或者计算结果：
\begin{lstlisting}[language=Python]
>>> print(300)
300
>>> print(100 + 200)
300
\end{lstlisting}

考虑到print()会依次打印每个字符串，我们可以把计算100 + 200的结果打印得更漂亮一点：
\begin{lstlisting}[language=Python]
>>> print('100 + 200 =', 100 + 200)
100 + 200 = 300
\end{lstlisting}
其中，对于100 + 200，Python解释器自动计算出结果300。但是，'100 + 200 ='是字符串而非数学公式，Python把它视为字符串，直接输出。



\subsection{格式化输出}
Python中的格式化输出是以字符串的形式进行格式化输出。尽管格式化输出可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符\%s 的字符串中。在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。如下实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

print "My name is %s and weight is %d kg!" % ('Zara', 21) 
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
My name is Zara and weight is 21 kg!
\end{lstlisting}

python字符串格式化符号：

\begin{tabular}{l|l}
符   号	& 描述\\
      \%c	& 格式化字符及其ASCII码\\
      \%s	& 格式化字符串\\
      \%d	& 格式化整数\\
      \%u	& 格式化无符号整型\\
      \%o	& 格式化无符号八进制数\\
      \%x	& 格式化无符号十六进制数\\
      \%X	& 格式化无符号十六进制数（大写）\\
      \%f	& 格式化浮点数字，可指定小数点后的精度\\
      \%e	& 用科学计数法格式化浮点数\\
      \%E	& 作用同\%e，用科学计数法格式化浮点数\\
      \%g	& \%f和\%e的简写\\
      \%G	& \%f 和 \%E 的简写\\
      \%p	& 用十六进制数格式化变量的地址
\end{tabular}

格式化操作符辅助指令：

\begin{tabular}{l|l}
符号&	功能\\
*	&定义宽度或者小数点精度\\
-	&用做左对齐\\
+	&在正数前面显示加号( + )\\
<sp>&	在正数前面显示空格\\
\#	&在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')\\
0	&显示的数字前面填充'0'而不是默认的空格\\
\%	& '\%\%'输出一个单一的'\%'\\
(var)	&映射变量(字典参数)\\
m.n.	&m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)
\end{tabular}



\subsection{格式化输出举例}
使用print输出各型的
\begin{itemize}
\item 字符串
\item 整数
\item 浮点数
\item 出度及精度控制
\end{itemize}

例如：
\begin{lstlisting}[language=Python]
h=int(5.32)
print '-'%h
print 'd'%h
\end{lstlisting}
输出 ' 5'，5前面有空格保持两位数；输出 '05' ，5前面有0保持两位数。
 
 \begin{lstlisting}[language=Python]
strHello = 'Hello Python' 
print strHello 
\end{lstlisting}
输出：Hello Python，直接出字符串。


\subsubsection{格式化输出整数}
python print也支持参数格式化，与C言的printf似，
 \begin{lstlisting}[language=Python]
strHello = "the length of (%s) is %d" %('Hello World',len('Hello World'))
print strHello
\end{lstlisting}
输出：the length of (Hello World) is 11


\subsubsection{格式化输出16制整数}
nHex = 0x20
\begin{itemize}
\item \%x --- hex 十六进制
\item \%d --- dec 十进制
\item \%o --- oct 八进制
\end{itemize}
 
 \begin{lstlisting}[language=Python]
print "nHex = %x,nDec = %d,nOct = %o" %(nHex,nHex,nHex)
 \end{lstlisting}
输出结果：nHex = 20,nDec = 32,nOct = 40，使用整数的各个制打印同一个数。


\subsubsection{格式化输出浮点数}
 \begin{lstlisting}[language=Python]
import math
#default
print "PI = %f" % math.pi

#width = 10,precise = 3,align = left
print "PI = .3f" % math.pi

#width = 10,precise = 3,align = rigth
print "PI = %-10.3f" % math.pi

#前面填充字符
print "PI = d" % int(math.pi)
  \end{lstlisting}
输出结果
 \begin{lstlisting}[language=Python]
PI = 3.141593
PI =      3.142
PI = 3.142
PI = 000003
  \end{lstlisting}
%浮点数的格式化，精度、度和


\subsubsection{格式化输出字符串}
 \begin{lstlisting}[language=Python]
#precise = 3
print "%.3s " % ("jcodeer")
#precise = 4
print "%.*s" % (4,"jcodeer")
#width = 10,precise = 3
print ".3s" % ("jcodeer")
  \end{lstlisting}
输出结果：
 \begin{lstlisting}[language=Python]
jco
jcod
       jco
  \end{lstlisting}
%同于字符串也存在精度、度和。



\subsection{python读入csv的三种方式}
读数据到python有好几种方法，我们以读取iris.csv为例，将其中的数值部分提取出来。

第一种方法是列表理解，文件读取到lines之后用一个嵌套的列表理解就可以将数值存为一个list。

第二种方法是使用numpy库，它内带的loadtxt函数，读取的数据都认作是字符串，所以在第二行取我们需要的部分，并转为数值array。

第三种方法是使用pandas库，它内带read\_csv函数，读取数据会自动判断数值还是字符串，而且会自动保存好变量名，只需要用ix方法就可以类似R一样取出需要的子集，它存为dataframe对象。

这三种方法中最后一种最简单，不过花费时间比较长一点，第一种最麻烦，不过用时最短。这个可以通过ipython中的magic函数timeit来看。











\section{文件及目录操作}
\begin{itemize}
\item file 对象方法: file对象提供了操作文件的一系列方法。
\item os 对象方法: 提供了处理文件及目录的一系列方法。
\end{itemize}



\subsection{打开和关闭文件}
Python提供了必要的函数和方法进行默认情况下的文件基本操作，可以用file对象做大部分的文件操作。


\subsubsection{open函数}
先用Python内置的open()函数打开一个文件，创建一个file对象，相关的辅助方法才可以调用它进行读写。语法如下：
 \begin{lstlisting}[language=Python]
file object = open(file_name [, access_mode][, buffering])
  \end{lstlisting}
各个参数的细节：
\begin{itemize}
\item \verb|file_name|：\verb|file_name|变量是一个包含了你要访问的文件名称的字符串值。

\item \verb|access_mode|：\verb|access_mode|决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。

\item buffering：如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。
\end{itemize}

不同模式打开文件的完全列表：
\begin{itemize}
\item 模式：描述
\item r	：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
\item rb	：以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。
\item r+	：打开一个文件用于读写。文件指针将会放在文件的开头。
\item rb+	：以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。
\item w	：打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
\item wb	：以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
\item w+	：打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
\item wb+	：以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
\item a	：打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
\item ab	：以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
\item a+	：打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
\item ab+	：以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。
\end{itemize}



\subsubsection{file 对象的属性}
一个文件被打开后，就有一个file对象，可以得到有关该文件的各种信息。以下是和file对象相关的所有属性的列表：
\begin{itemize}
\item 属性：描述
\item file.closed	：返回true如果文件已被关闭，否则返回false。
\item file.mode	：返回被打开文件的访问模式。
\item file.name	：返回文件的名称。
\item file.softspace	：如果用print输出后，必须跟一个空格符，则返回false。否则返回true。
\end{itemize}
如下实例：
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 打开一个文件
fo = open("foo.txt", "wb")
print "Name of the file: ", fo.name
print "Closed or not : ", fo.closed
print "Opening mode : ", fo.mode
print "Softspace flag : ", fo.softspace
  \end{lstlisting}
以上实例输出结果：
 \begin{lstlisting}[language=Python]
Name of the file:  foo.txt
Closed or not :  False
Opening mode :  wb
Softspace flag :  0
  \end{lstlisting}



\subsubsection{close()方法}
file对象的close()方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。
当一个文件对象的引用被重新指定给另一个文件时，Python会关闭之前的文件。用close()方法关闭文件是一个很好的习惯。

语法：
 \begin{lstlisting}[language=Python]
 fileobject.close();
  \end{lstlisting}

例子：
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 打开一个文件
fo = open("foo.txt", "wb")
print "Name of the file: ", fo.name
 
# 关闭打开的文件
fo.close()
  \end{lstlisting}
以上实例输出结果：
 \begin{lstlisting}[language=Python]
Name of the file:  foo.txt
  \end{lstlisting}



\subsection{读取和写入文件}
\subsubsection{write()方法}
write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。write()方法不在字符串的结尾不添加换行符('\verb|\n|')。

语法：
 \begin{lstlisting}[language=Python]
fileobject.write(string);
  \end{lstlisting}

在这里，被传递的参数是要写入到已打开文件的内容。例如：
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 打开一个文件
fo = open("/tmp/foo.txt", "wb")
fo.write( "Python is a great language.\nYeah its great!!\n");
 
# 关闭打开的文件
fo.close()
  \end{lstlisting}
上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:
 \begin{lstlisting}[language=Python]
Python is a great language.
Yeah its great!!
  \end{lstlisting}



\subsubsection{read() 方法}
read()方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。

语法：

 \begin{lstlisting}[language=Python]
fileobject.read([count]);
  \end{lstlisting}
在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。

例如：
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 打开一个文件
fo = open("/tmp/foo.txt", "r+")
str = fo.read(10);
print "Read String is : ", str
# 关闭打开的文件
fo.close()
  \end{lstlisting}

输出结果：
 \begin{lstlisting}[language=Python]
Read String is :  Python is
  \end{lstlisting}



\subsubsection{文件位置}
tell()方法告诉你文件内的当前位置；换句话说，下一次的读写会发生在文件开头这么多字节之后。

seek(offset [,from])方法改变当前文件的位置。offset变量表示要移动的字节数。from变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。

例如：
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 打开一个文件
fo = open("/tmp/foo.txt", "r+")
str = fo.read(10);
print "Read String is : ", str
 
# 查找当前位置
position = fo.tell();
print "Current file position : ", position
 
# 把指针再次重新定位到文件开头
position = fo.seek(0, 0);
str = fo.read(10);
print "Again read String is : ", str
# 关闭打开的文件
fo.close()
  \end{lstlisting}
实例输出结果：
 \begin{lstlisting}[language=Python]
Read String is :  Python is
Current file position :  10
Again read String is :  Python is
  \end{lstlisting}



\subsection{重命名和删除文件}
Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。
要使用这个模块，你必须先导入它，然后可以调用相关的各种功能。



\subsubsection{rename()方法}
rename()方法需要两个参数，当前的文件名和新文件名。

语法：
 \begin{lstlisting}[language=Python]
os.rename(current_file_name, new_file_name)
  \end{lstlisting}

例如：下例将重命名一个已经存在的文件test1.txt。
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
import os
 
# 重命名文件test1.txt到test2.txt。
os.rename( "test1.txt", "test2.txt" )
  \end{lstlisting}



\subsubsection{remove()方法}
用remove()方法删除文件，需要提供要删除的文件名作为参数。

语法：
 \begin{lstlisting}[language=Python]
os.remove(file_name)
  \end{lstlisting}

例如：删除一个已经存在的文件test2.txt。
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
import os
 
# 删除一个已经存在的文件test2.txt
os.remove("text2.txt")
  \end{lstlisting}



\subsection{创建和删除目录}
所有文件都包含在各个不同的目录下，Python也能轻松处理。os模块有许多方法能创建，删除和更改目录。
\subsubsection{mkdir() 方法}
可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。

语法：
 \begin{lstlisting}[language=Python]
os.mkdir("newdir")
  \end{lstlisting}

例如：在当前目录下创建一个新目录test
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
import os
 
# 创建目录test
os.mkdir("test")
  \end{lstlisting}



\subsubsection{chdir() 方法}
可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。

语法：
 \begin{lstlisting}[language=Python]
os.chdir("newdir")
  \end{lstlisting}

例如：
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
import os
 
# 将当前目录改为"/home/newdir"
os.chdir("/home/newdir")
  \end{lstlisting}



\subsubsection{getcwd() 方法}
getcwd()方法显示当前的工作目录。

语法：
 \begin{lstlisting}[language=Python]
os.getcwd()
  \end{lstlisting}

例如：
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
import os
 
# 给出当前的目录
os.getcwd()
  \end{lstlisting}



\subsubsection{rmdir()方法}
rmdir()方法删除目录，目录名称以参数传递。需要注意的是，在删除这个目录之前，它的所有内容应该先被清除。

语法：
 \begin{lstlisting}[language=Python]
os.rmdir('dirname')
  \end{lstlisting}

例如：
 \begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
import os
 
# 删除”/tmp/test”目录
os.rmdir( "/tmp/test"  )
  \end{lstlisting}









\section{运算符}
Python语言支持以下类型的运算符：
\begin{itemize}
\item 算术运算符
\item 比较（关系）运算符
\item 赋值运算符
\item 逻辑运算符
\item 位运算符
\item 成员运算符
\item 身份运算符
\end{itemize}


\subsection{算术运算符}
以下假设变量a为10，变量b为20：

\begin{tabular}{l|l|l}
运算符&	描述&	实例\\
+&	加 - 两个对象相加&	a + b 输出结果 30\\
-&	减 - 得到负数或是一个数减去另一个数&	a - b 输出结果 -10\\
*&	乘 - 两个数相乘或是返回一个被重复若干次的字符串&	a * b 输出结果 200\\
/&	除 - x除以y&	b / a 输出结果 2\\
\%&	取模 - 返回除法的余数&	b\% a 输出结果 0\\
**&	幂 - 返回x的y次幂	&a**b 为10的20次方， 输出结果 100000000000000000000\\
//&	取整除 - 返回商的整数部分	&9//2 输出结果 4 , 9.0//2.0 输出结果 4.0
\end{tabular}


\subsection{比较运算符}
以下假设变量a为10，变量b为20：

\begin{tabular}{l|l|l}
运算符&	描述&	实例\\
==&	等于 - 比较对象是否相等&	(a == b) 返回 False\\
!=&	不等于 - 比较两个对象是否不相等&	(a != b) 返回 true\\
<>	&不等于 - 比较两个对象是否不相等&	(a <> b) 返回 true，这个运算符类似 != \\
>	&大于 - 返回x是否大于y&	(a > b) 返回 False\\
<	&小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写&	(a < b) 返回 true\\
>=	&大于等于 - 返回x是否大于等于y&	(a >= b) 返回 False\\
<=	&小于等于 - 返回x是否小于等于y&	(a <= b) 返回 true
\end{tabular}



\subsection{赋值运算符}
\begin{tabular}{l|l|l}
运算符&	描述&	实例\\
=&	简单的赋值运算符&	c = a + b 将 a + b 的运算结果赋值为 c\\
+=&	加法赋值运算符&	c += a 等效于 c = c + a\\
-=&	减法赋值运算符&	c -= a 等效于 c = c - a\\
*=&	乘法赋值运算符&	c *= a 等效于 c = c * a\\
/=&	除法赋值运算符&	c /= a 等效于 c = c / a\\
\%=&	取模赋值运算符&	c \%= a 等效于 c = c \% a\\
**=&	幂赋值运算符&	c **= a 等效于 c = c ** a\\
//=&	取整除赋值运算符&	c //= a 等效于 c = c // a
\end{tabular}


\subsection{位运算符}
按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：
以下假设变量a为60，变量b为13：

\begin{tabular}{l|l|l}
运算符&	描述&	实例\\
\& &	按位与运算符&	 (a \& b) 输出结果 12 ，二进制解释： 0000 1100\\
|&	按位或运算符&	(a | b) 输出结果 61 ，二进制解释： 0011 1101\\
%{\^} &	按位异或运算符&	(a \^ b) 输出结果 49 ，二进制解释： 0011 0001\\
$\sim$	&按位取反运算符&	($\sim$a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式\\
<<&	左移动运算符	&a << 2 输出结果 240 ，二进制解释： 1111 0000\\
>>&	右移动运算符	&a >> 2 输出结果 15 ，二进制解释： 0000 1111
\end{tabular}


\subsection{逻辑运算符}
Python语言支持逻辑运算符，以下假设变量a为10，变量b为20：

\begin{tabular}{l|l|l}
运算符&	描述&	实例\\
and&	布尔"与" - 如果x为False，x and y返回False，否则它返回y的计算值。&	(a and b) 返回 true。\\
or&	布尔"或" - 如果x是True，它返回True，否则它返回y的计算值。&	(a or b) 返回 true。\\
not	&布尔"非" - 如果x为True，返回False。如果x为False，它返回True。&	not(a and b) 返回 false。
\end{tabular}


\subsection{成员运算符}
Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。

\begin{tabular}{l|l|l}
运算符&	描述&	实例\\
in&	如果在指定的序列中找到值返回True，否则返回False。	&x 在 y序列中 , 如果x在y序列中返回True。\\
not in&	如果在指定的序列中没有找到值返回True，否则返回False。	&x 不在 y序列中 , 如果x不在y序列中返回True。
\end{tabular}
以下实例演示了Python所有成员运算符的操作：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

a = 10
b = 20
list = [1, 2, 3, 4, 5 ];

if ( a in list ):
   print "Line 1 - a is available in the given list"
else:
   print "Line 1 - a is not available in the given list"

if ( b not in list ):
   print "Line 2 - b is not available in the given list"
else:
   print "Line 2 - b is available in the given list"

a = 2
if ( a in list ):
   print "Line 3 - a is available in the given list"
else:
   print "Line 3 - a is not available in the given list"
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
Line 1 - a is not available in the given list
Line 2 - b is not available in the given list
Line 3 - a is available in the given list
\end{lstlisting}


\subsection{身份运算符}
身份运算符用于比较两个对象的存储单元。

\begin{tabular}{l|l|l}
运算符&	描述&	实例\\
is&	is是判断两个标识符是不是引用自一个对象	&x is y, 如果 id(x) 等于 id(y) , is 返回结果 1\\
is no&t	is not是判断两个标识符是不是引用自不同对象	&x is not y, 如果 id(x) 不等于 id(y). is not 返回结果 1
\end{tabular}
以下实例演示了Python所有身份运算符的操作：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

a = 20
b = 20

if ( a is b ):
   print "Line 1 - a and b have same identity"
else:
   print "Line 1 - a and b do not have same identity"

if ( id(a) == id(b) ):
   print "Line 2 - a and b have same identity"
else:
   print "Line 2 - a and b do not have same identity"

b = 30
if ( a is b ):
   print "Line 3 - a and b have same identity"
else:
   print "Line 3 - a and b do not have same identity"

if ( a is not b ):
   print "Line 4 - a and b do not have same identity"
else:
   print "Line 4 - a and b have same identity"
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
Line 1 - a and b have same identity
Line 2 - a and b have same identity
Line 3 - a and b do not have same identity
Line 4 - a and b do not have same identity 
\end{lstlisting}


\subsection{运算符优先级}
以下表格列出了从最高到最低优先级的所有运算符：

\begin{tabular}{l|l}
运算符	&描述\\
**&	指数 (最高优先级)\\
~ + -&	按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)\\
* / \% //	&乘，除，取模和取整除\\
+ -&	加法减法\\
>> <<	&右移，左移运算符\\
\&	 &位 'AND'\\
\verb|^|  | &	位运算符\\
<= < > >=	&比较运算符\\
<> == !=	&等于运算符\\
= \%= /= //= -= += *= **=	&赋值运算符\\
is is not&	身份运算符\\
in not in&	成员运算符\\
not or and&	逻辑运算符
\end{tabular}


\section{条件语句}
条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。编程中 if 语句用于控制程序的执行，基本形式为：
\begin{lstlisting}[language=Python]
if 判断条件：
    执行语句……
else：
    执行语句……
\end{lstlisting}
其中"判断条件"成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句，具体例子如下：
\begin{lstlisting}[language=Python]
# coding=utf8
# 例1：if 基本用法

flag = False
name = 'luren'
if name == 'python':         # 判断变量否为'python'
    flag = True          # 条件成立时设置标志为真
    print 'welcome boss'    # 并输出欢迎信息
else:
    print name              # 条件不成立时输出变量名称
\end{lstlisting}
输出结果为：
\begin{lstlisting}[language=Python]
>>> luren			# 输出结果
\end{lstlisting}

if 语句的判断条件可以用>（大于）、<(小于)、==（等于）、>=（大于等于）、<=（小于等于）来表示其关系。当判断条件为多个值是，可以使用以下形式：
\begin{lstlisting}[language=Python]
if 判断条件1:
    执行语句1……
elif 判断条件2:
    执行语句2……
elif 判断条件3:
    执行语句3……
else:
    执行语句4……
\end{lstlisting}
实例如下：
\begin{lstlisting}[language=Python]
# coding=utf8
# 例2：elif用法

num = 5     
if num == 3:            # 判断num的值
    print 'boss'        
elif num == 2:
    print 'user'
elif num == 1:
    print 'worker'
elif num < 0:           # 值小于零时输出
    print 'error'
else:
    print 'roadman'     # 条件均不成立时输出
\end{lstlisting}
输出结果为：
\begin{lstlisting}[language=Python]
>>> roadman		# 输出结果
\end{lstlisting}

由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。
\begin{lstlisting}[language=Python]
# coding=utf8
# 例3：if语句多个条件

num = 9
if num >= 0 and num <= 10:    # 判断值是否在0~10之间
    print 'hello'
>>> hello		# 输出结果

num = 10
if num < 0 or num > 10:    # 判断值是否在小于0或大于10
    print 'hello'
else:
	print 'undefine'
>>> undefine		# 输出结果

num = 8
# 判断值是否在0~5或者10~15之间
if (num >= 0 and num <= 5) or (num >= 10 and num <= 15):    
    print 'hello'
else:
    print 'undefine'
>>> undefine		# 输出结果
\end{lstlisting}
当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于>（大于）、<（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。

也可以在同一行的位置上使用if条件判断语句，如下实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python 
 
var = 100 
 
if ( var  == 100 ) : print "Value of expression is 100" 
 
print "Good bye!" 
\end{lstlisting}
以上代码执行输出结果如下：
\begin{lstlisting}[language=Python]
Value of expression is 100
Good bye!
\end{lstlisting}



\section{循环语句}
\subsection{for循环}
Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。for循环的语法格式如下：
\begin{lstlisting}[language=Python]
for iterating_var in sequence:
   statements(s)
\end{lstlisting}
实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

for letter in 'Python':     # First Example
   print 'Current Letter :', letter

fruits = ['banana', 'apple',  'mango']
for fruit in fruits:        # Second Example
   print 'Current fruit :', fruit

print "Good bye!"
\end{lstlisting}
以上实例输出结果:
\begin{lstlisting}[language=Python]
Current Letter : P
Current Letter : y
Current Letter : t
Current Letter : h
Current Letter : o
Current Letter : n
Current fruit : banana
Current fruit : apple
Current fruit : mango
Good bye!
\end{lstlisting}

另外一种执行循环的遍历方式是通过索引，如下实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

fruits = ['banana', 'apple',  'mango']
for index in range(len(fruits)):
   print 'Current fruit :', fruits[index]

print "Good bye!"
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
Current fruit : banana
Current fruit : apple
Current fruit : mango
Good bye!
\end{lstlisting}
以上实例我们使用了内置函数 len() 和 range()。函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数。

在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。如下实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

for num in range(10,20):  #to iterate between 10 to 20
   for i in range(2,num): #to iterate on the factors of the number
      if num%i == 0:      #to determine the first factor
         j=num/i          #to calculate the second factor
         print '%d equals %d * %d' % (num,i,j)
         break #to move to the next number, the #first FOR
   else:                  # else part of the loop
      print num, 'is a prime number'
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
10 equals 2 * 5
11 is a prime number
12 equals 2 * 6
13 is a prime number
14 equals 2 * 7
15 equals 3 * 5
16 equals 2 * 8
17 is a prime number
18 equals 2 * 9
19 is a prime number
\end{lstlisting}


\subsection{while循环}
Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：
\begin{lstlisting}[language=Python]
while 判断条件：
    执行语句……
\end{lstlisting}
执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。
当判断条件假false时，循环结束。
实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

count = 0
while (count < 9):
   print 'The count is:', count
   count = count + 1

print "Good bye!"
\end{lstlisting}
以上代码执行输出结果:
\begin{lstlisting}[language=Python]
The count is: 0
The count is: 1
The count is: 2
The count is: 3
The count is: 4
The count is: 5
The count is: 6
The count is: 7
The count is: 8
Good bye!
\end{lstlisting}

如果条件判断语句永远为 true，循环将会无限的执行下去，如下实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

var = 1
while var == 1 :  # 该条件永远为true，循环将无限执行下去
   num = raw_input("Enter a number  :")
   print "You entered: ", num

print "Good bye!"
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
Enter a number  :20
You entered:  20
Enter a number  :29
You entered:  29
Enter a number  :3
You entered:  3
Enter a number between :Traceback (most recent call last):
  File "test.py", line 5, in <module>
    num = raw_input("Enter a number :")
KeyboardInterrupt
\end{lstlisting}
注意：以上的无限循环你可以使用 CTRL+C 来中断循环。

像for循环一样，while循环也可以用else语句，else中的语句会在循环正常执行完后执行，如下：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

count = 0
while count < 5:
   print count, " is  less than 5"
   count = count + 1
else:
   print count, " is not less than 5"
\end{lstlisting}
以上实例输出结果为：
\begin{lstlisting}[language=Python]
0 is less than 5
1 is less than 5
2 is less than 5
3 is less than 5
4 is less than 5
5 is not less than 5
\end{lstlisting}

类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

flag = 1

while (flag): print 'Given flag is really true!'

print "Good bye!"
\end{lstlisting}
注意：以上的无限循环你可以使用 CTRL+C 来中断循环。


\subsection{循环嵌套}
Python 语言允许在一个循环体里面嵌入另一个循环。

Python for 循环嵌套语法：
\begin{lstlisting}[language=Python]
for iterating_var in sequence:
   for iterating_var in sequence:
      statements(s)
   statements(s)
\end{lstlisting}

Python while 循环嵌套语法：
\begin{lstlisting}[language=Python]
while expression:
   while expression:
      statement(s)
   statement(s)
\end{lstlisting}
可以在循环体内嵌入其他的循环体，如在while循环中可以嵌入for循环， 反之，你可以在for循环中嵌入while循环。

实例：

以下实例使用了嵌套循环输出2$\sim$100之间的素数：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

i = 2
while(i < 100):
   j = 2
   while(j <= (i/j)):
      if not(i%j): break
      j = j + 1
   if (j > i/j) : print i, " 是素数"
   i = i + 1

print "Good bye!"
\end{lstlisting}
以上实例输出结果:
\begin{lstlisting}[language=Python]
2 是素数
3 是素数
5 是素数
7 是素数
11 是素数
13 是素数
17 是素数
19 是素数
23 是素数
29 是素数
31 是素数
37 是素数
41 是素数
43 是素数
47 是素数
53 是素数
59 是素数
61 是素数
67 是素数
71 是素数
73 是素数
79 是素数
83 是素数
89 是素数
97 是素数
Good bye!
\end{lstlisting}


\section{循环控制语句}
\subsection{break语句}
Python break语句，就像在C语言中，打破了最小封闭for或while循环。
break语句用来终止循环语句，即循环条件没有False条件或者序列还没被完全递归完，也会停止执行循环语句。
break语句用在while和for循环中。
如果使用嵌套循环，break语句将停止执行最深层的循环，并开始执行下一行代码。

Python语言 break 语句语法：
\begin{lstlisting}[language=Python]
break
\end{lstlisting}
实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

for letter in 'Python':     # First Example
   if letter == 'h':
      break
   print 'Current Letter :', letter
  
var = 10                    # Second Example
while var > 0:              
   print 'Current variable value :', var
   var = var -1
   if var == 5:
      break

print "Good bye!"
\end{lstlisting}
以上实例执行结果：
\begin{lstlisting}[language=Python]
Current Letter : P
Current Letter : y
Current Letter : t
Current variable value : 10
Current variable value : 9
Current variable value : 8
Current variable value : 7
Current variable value : 6
Good bye!
\end{lstlisting}


\subsection{continue语句}
Python continue 语句跳出本次循环，而break跳出整个循环。
continue 语句用来告诉Python跳过当前循环的剩余语句，然后继续进行下一轮循环。
continue语句用在while和for循环中。

Python 语言 continue 语句语法格式如下：
\begin{lstlisting}[language=Python]
continue
\end{lstlisting}
实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

for letter in 'Python':     # First Example
   if letter == 'h':
      continue
   print 'Current Letter :', letter

var = 10                    # Second Example
while var > 0:              
   var = var -1
   if var == 5:
      continue
   print 'Current variable value :', var
print "Good bye!"
\end{lstlisting}
以上实例执行结果：
\begin{lstlisting}[language=Python]
Current Letter : P
Current Letter : y
Current Letter : t
Current Letter : o
Current Letter : n
Current variable value : 9
Current variable value : 8
Current variable value : 7
Current variable value : 6
Current variable value : 4
Current variable value : 3
Current variable value : 2
Current variable value : 1
Current variable value : 0
Good bye!
\end{lstlisting}


\subsection{pass语句}
Python pass是空语句，是为了保持程序结构的完整性。

Python 语言 pass 语句语法格式如下：
\begin{lstlisting}[language=Python]
pass
\end{lstlisting}
实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

for letter in 'Python': 
   if letter == 'h':
      pass
      print 'This is pass block'
   print 'Current Letter :', letter

print "Good bye!"
\end{lstlisting}
以上实例执行结果：
\begin{lstlisting}[language=Python]
Current Letter : P
Current Letter : y
Current Letter : t
This is pass block
Current Letter : h
Current Letter : o
Current Letter : n
Good bye!
\end{lstlisting}



\section{函数}
函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。


\subsection{定义函数}
函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。
\begin{itemize}
\item 函数代码块以def关键词开头，后接函数标识符名称和圆括号()。
\item 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。
\item 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
\item 函数内容以冒号起始，并且缩进。
\item Return[expression]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。
\end{itemize}

语法：
\begin{lstlisting}[language=Python]
def functionname( parameters ):
   "函数_文档字符串"
   function_suite
   return [expression]
\end{lstlisting}
默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。

实例：
以下为一个简单的Python函数，它将一个字符串作为传入参数，再打印到标准显示设备上。
\begin{lstlisting}[language=Python]
def printme( str ):
   "打印传入的字符串到标准显示设备上"
   print str
   return
\end{lstlisting}


\subsection{函数调用}
定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。

这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。

如下实例调用了printme（）函数：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# Function definition is here
def printme( str ):
   "打印任何传入的字符串"
   print str;
   return;
 
# Now you can call printme function
printme("我要调用用户自定义函数!");
printme("再次调用同一函数");
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
我要调用用户自定义函数!
再次调用同一函数
\end{lstlisting}


\subsection{函数参数}
以下是调用函数时可使用的正式参数类型：
\begin{itemize}
\item 必备参数
\item 命名参数
\item 缺省参数
\item 不定长参数
\end{itemize}


\subsubsection{必备参数}
必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。

调用printme()函数，你必须传入一个参数，不然会出现语法错误：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
#可写函数说明
def printme( str ):
   "打印任何传入的字符串"
   print str;
   return;
 
#调用printme函数
printme();
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
Traceback (most recent call last):
  File "test.py", line 11, in <module>
    printme();
TypeError: printme() takes exactly 1 argument (0 given)
\end{lstlisting}


\subsubsection{命名参数}
命名参数和函数调用关系紧密，调用方用参数的命名确定传入的参数值。你可以跳过不传的参数或者乱序传参，因为Python解释器能够用参数名匹配参数值。用命名参数调用printme()函数：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
#可写函数说明
def printme( str ):
   "打印任何传入的字符串"
   print str;
   return;
 
#调用printme函数
printme( str = "My string");
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
My string
\end{lstlisting}

下例能将命名参数顺序不重要展示得更清楚：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
#可写函数说明
def printinfo( name, age ):
   "打印任何传入的字符串"
   print "Name: ", name;
   print "Age ", age;
   return;
 
#调用printinfo函数
printinfo( age=50, name="miki" );
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
Name:  miki
Age  50
\end{lstlisting}


\subsubsection{缺省参数}
调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
#可写函数说明
def printinfo( name, age = 35 ):
   "打印任何传入的字符串"
   print "Name: ", name;
   print "Age ", age;
   return;
 
#调用printinfo函数
printinfo( age=50, name="miki" );
printinfo( name="miki" );
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
Name:  miki
Age  50
Name:  miki
Age  35
\end{lstlisting}


\subsubsection{不定长参数}
可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：
\begin{lstlisting}[language=Python]
def functionname([formal_args,] *var_args_tuple ):
   "函数_文档字符串"
   function_suite
   return [expression]
\end{lstlisting}
加了星号（*）的变量名会存放所有未命名的变量参数。选择不多传参数也可。如下实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 可写函数说明
def printinfo( arg1, *vartuple ):
   "打印任何传入的参数"
   print "输出: "
   print arg1
   for var in vartuple:
      print var
   return;
 
# 调用printinfo 函数
printinfo( 10 );
printinfo( 70, 60, 50 );
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
输出:
10
输出:
70
60
50
\end{lstlisting}


\subsection{匿名函数}
用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。
\begin{itemize}
\item Lambda函数能接收任何数量的参数但只能返回一个表达式的值，同时只能不能包含命令或多个表达式。
\item 匿名函数不能直接调用print，因为lambda需要一个表达式。
\item lambda函数拥有自己的名字空间，且不能访问自有参数列表之外或全局名字空间里的参数。
\item 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。
\end{itemize}
如下实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
#可写函数说明
sum = lambda arg1, arg2: arg1 + arg2;
 
#调用sum函数
print "Value of total : ", sum( 10, 20 )
print "Value of total : ", sum( 20, 20 )
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
Value of total :  30
Value of total :  40
\end{lstlisting}


\subsection{return语句}
return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 可写函数说明
def sum( arg1, arg2 ):
   # 返回2个参数的和."
   total = arg1 + arg2
   print "Inside the function : ", total
   return total;
 
# 调用sum函数
total = sum( 10, 20 );
print "Outside the function : ", total 
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
Inside the function :  30
Outside the function :  30
\end{lstlisting}


\subsection{局部和全局变量}
一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。

变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：
全局变量、局部变量

定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。

局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
total = 0; # This is global variable.
# 可写函数说明
def sum( arg1, arg2 ):
   #返回2个参数的和."
   total = arg1 + arg2; # total在这里是局部变量.
   print "Inside the function local total : ", total
   return total;
 
#调用sum函数
sum( 10, 20 );
print "Outside the function global total : ", total 
\end{lstlisting}
输出结果：
\begin{lstlisting}[language=Python]
Inside the function local total :  30
Outside the function global total :  0
\end{lstlisting}





\subsection{数学常量}
\begin{tabular}{l|l}
常量&	描述\\
pi	&数学常量 pi（圆周率，一般以π来表示）\\
e	&数学常量 e，e即自然常数（自然常数）
\end{tabular}



\subsection{数学函数——math模块}
\begin{tabular}{l|l}
函数&	返回值 ( 描述 )\\
abs(x)&	返回数字的绝对值，如abs(-10) 返回 10\\
cmp(x, y)&	如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1\\
max(x1, x2,...)&	返回给定参数的最大值，参数可以为序列。\\
min(x1, x2,...)&	返回给定参数的最小值，参数可以为序列。\\
modf(x)&	返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。\\
pow(x, y)&	x**y 运算后的值。\\
round(x [,n])&	返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。\\
ceil(x)	&返回数字的上入整数，如math.ceil(4.1) 返回 5\\
floor(x)	&返回数字的下舍整数，如math.floor(4.9)返回 4\\
exp(x)	&返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045\\
log10(x)&	返回以10为基数的x的对数，如math.log10(100)返回 2.0\\
log(x)	&如math.log(math.e)返回1.0,math.log(100,10)返回2.0\\
fabs(x)	&返回数字的绝对值，如math.fabs(-10) 返回10.0\\
sqrt(x)&	返回数字x的平方根，数字可以为负数，返回类型为实数，如math.sqrt(4)返回 2+0j
\end{tabular}

其中有些需要导入math模块，通过静态对象调用该方法，如ceil()用法：
\begin{lstlisting}[language=Python]
import math

math.ceil( x )
\end{lstlisting}


三角函数

\begin{tabular}{l|l}
函数	&描述\\
acos(x)	&返回x的反余弦弧度值。\\
asin(x)	&返回x的反正弦弧度值。\\	
atan(x)	&返回x的反正切弧度值。\\
atan2(y, x)&	返回给定的 X 及 Y 坐标值的反正切值。\\
cos(x)&	返回x的弧度的余弦值。\\
hypot(x, y)&	返回欧几里德范数 sqrt(x*x + y*y)。\\
sin(x)&	返回的x弧度的正弦值。\\
tan(x)	&返回x弧度的正切值。\\
degrees(x)&	将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0\\
radians(x)	&将角度转换为弧度
\end{tabular}




\subsection{随机数函数——random模块}
随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。

Python包含以下常用随机数函数：
\begin{itemize}
\item choice(seq)：	从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。
\item randrange ([start,] stop [,step])：	从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1
\item random()：	随机生成下一个实数，它在[0,1)范围内。
\item seed([x])：	改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。
\item shuffle(lst)：	将序列的所有元素随机排序
\item uniform(x, y)：	随机生成下一个实数，它在[x,y]范围内。
\end{itemize}

注意：这些函数都不能直接访问，需要导入 random 模块，然后通过 random 静态对象调用该方法。






\section{模块}
模块让你能够有逻辑地组织你的Python代码段。
把相关的代码分配到一个 模块里能让你的代码更好用，更易懂。
模块也是Python对象，具有随机的名字属性用来绑定或引用。
简单地说，模块就是一个保存了Python代码的文件。模块能定义函数，类和变量。模块里也能包含可执行的代码。

例如：
一个叫做aname的模块里的Python代码一般都能在一个叫aname.py的文件中找到。下例是个简单的模块hello.py。
\begin{lstlisting}[language=Python]
def print_func( par ):
   print "Hello : ", par
   return
\end{lstlisting}



\subsection{import语句}
想使用Python源文件，只需在另一个源文件里执行import语句，语法如下：
\begin{lstlisting}[language=Python]
import module1[, module2[,... moduleN]
\end{lstlisting}
当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块hello.py，需要把命令放在脚本的顶端：

\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 导入模块
import hello
 
# 现在可以调用模块里包含的函数了
hello.print_func("Zara")
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
Hello : Zara
\end{lstlisting}
一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。



\subsection{from…import 语句}
Python的from语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：
\begin{lstlisting}[language=Python]
from modname import name1[, name2[, ... nameN]]
\end{lstlisting}
例如，要导入模块fib的fibonacci函数，使用如下语句：
\begin{lstlisting}[language=Python]
from fib import fibonacci
\end{lstlisting}
这个声明不会把整个fib模块导入到当前的命名空间中，它只会将fib里的fibonacci单个引入到执行这个声明的模块的全局符号表。



\subsection{from…import* 语句}
使用如下声明，可以把一个模块的所有内容全都导入到当前的命令空间：
\begin{lstlisting}[language=Python]
from modname import *
\end{lstlisting}
这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。



\subsection{定位模块}
当你导入一个模块，Python解析器对模块位置的搜索顺序是：
\begin{itemize}
\item 当前目录
\item 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录
\item 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/
\end{itemize}
模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。



\subsection{PYTHONPATH 变量}
作为环境变量，PYTHONPATH由装在一个列表里的许多目录组成。PYTHONPATH的语法和shell变量PATH的一样。

在Windows系统，典型的PYTHONPATH如下：
\begin{lstlisting}[language=Python]
set PYTHONPATH=c:\python20\lib;
\end{lstlisting}

在UNIX系统，典型的PYTHONPATH如下：
\begin{lstlisting}[language=Python]
set PYTHONPATH=/usr/local/lib/python
\end{lstlisting}



\subsection{命名空间和作用域}
变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。

一个Python表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。

每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。

Python会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。

因此，如果要给全局变量在一个函数里赋值，必须使用global语句。

global VarName的表达式会告诉Python， VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量了。

例如，我们在全局命名空间里定义一个变量money。我们再在函数内给变量money赋值，然后Python会假定money是一个局部变量。然而，我们并没有在访问前声明一个局部变量money，结果就是会出现一个UnboundLocalError的错误。取消global语句的注释就能解决这个问题。
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
Money = 2000
def AddMoney():
   # 想改正代码就取消以下注释:
   # global Money
   Money = Money + 1
 
print Money
AddMoney()
print Money
\end{lstlisting}



\subsection{dir()函数}
dir()函数一个排好序的字符串列表，内容是一个模块里定义过的名字。

返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# 导入内置math模块
import math
 
content = dir(math)
 
print content;
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
['__doc__', '__file__', '__name__', 'acos', 'asin', 'atan', 
'atan2', 'ceil', 'cos', 'cosh', 'degrees', 'e', 'exp', 
'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log',
'log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 
'sqrt', 'tan', 'tanh']
\end{lstlisting}
在这里，特殊字符串变量\verb|__name__|指向模块的名字，\verb|__file__|指向该模块的导入文件名。



\subsection{globals()和locals()函数}
根据调用地方的不同，globals()和locals()函数可被用来返回全局和局部命名空间里的名字。

如果在函数内部调用locals()，返回的是所有能在该函数里访问的命名。

如果在函数内部调用globals()，返回的是所有在该函数里能访问的全局名字。

两个函数的返回类型都是字典。所以名字们能用keys()函数摘取。



\subsection{reload() 函数}
当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。

因此，如果你想重新执行模块里顶层部分的代码，可以用reload()函数。该函数会重新导入之前导入过的模块。语法如下：
\begin{lstlisting}[language=Python]
reload(module_name)
\end{lstlisting}
在这里，module\_name要直接放模块的名字，而不是一个字符串形式。比如想重载hello模块，如下：
\begin{lstlisting}[language=Python]
reload(hello)
\end{lstlisting}



\subsection{ Python中的包}
包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的Python的应用环境。包的存在可以让我们一次性导入一个目录下的所有函数。

考虑一个在Phone目录下的pots.py文件。这个文件有如下源代码：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
def Pots():
   print "I'm Pots Phone"
\end{lstlisting}
同样地，我们有另外两个保存了不同函数的文件：
\begin{itemize}
\item Phone/Isdn.py 含有函数Isdn()
\item Phone/G3.py 含有函数G3()
\end{itemize}
现在，在Phone目录下创建\verb|__init__.py|：
\begin{lstlisting}[language=Python]
Phone/__init__.py
\end{lstlisting}

当要导入Phone时，为了能够使用所有函数，你需要在\verb|__init__.py|里使用显式的导入语句，如下：
\begin{lstlisting}[language=Python]
from Pots import Pots
from Isdn import Isdn
from G3 import G3
\end{lstlisting}
把这些代码添加到\verb|__init__.py|之后，导入Phone包的时候这些类就全都是可用的了。
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python
 
# Now import your Phone Package.
import Phone
 
Phone.Pots()
Phone.Isdn()
Phone.G3()
\end{lstlisting}
以上实例输出结果：
\begin{lstlisting}[language=Python]
I'm Pots Phone
I'm 3G Phone
I'm ISDN Phone
\end{lstlisting}
如上，为了举例，我们只在每个文件里放置了一个函数，但其实可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。




\section{面向对象}
\subsection{面向对象技术简介}
\begin{itemize}
\item 类(Class)： 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
\item 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
\item 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
\item 方法重载：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重载。
\item 实例变量：定义在方法中的变量，只作用于当前实例的类。
\item 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
\item 实例化：创建一个类的实例，类的具体对象。
\item 方法：类中定义的函数。
\item 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。
\end{itemize}



\subsection{创建类}
使用class语句来创建一个新类，class之后为类的名称并以冒号结尾，如下实例：
\begin{lstlisting}[language=Python]
class ClassName:
   '类的帮助信息'   #类文档字符串
   class_suite  #类体
\end{lstlisting}
类的帮助信息可以通过ClassName.\_\_doc\_\_查看。class\_suite 由类成员，方法，数据属性组成。



\subsubsection{实例}
以下是一个简单的Python类实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
class Employee:
   '所有员工的基类'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary
\end{lstlisting}
\begin{itemize}
\item empCount变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用Employee.empCount访问；

\item 第一种方法\_\_init\_\_()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法。
\end{itemize}



\subsubsection{创建实例对象}
要创建一个类的实例，你可以使用类的名称，并通\_\_init\_\_方法接受参数。
\begin{lstlisting}[language=Python]
"创建 Employee 类的第一个对象"
emp1 = Employee("Zara", 2000)
"创建 Employee 类的第二个对象"
emp2 = Employee("Manni", 5000)
\end{lstlisting}



\subsubsection{访问属性}
可以使用点(.)来访问对象的属性。使用如下类的名称访问类变量：
\begin{lstlisting}[language=Python]
emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount
\end{lstlisting}



\subsubsection{完整实例}
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

class Employee:
   '所有员工的基类'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary

"创建 Employee 类的第一个对象"
emp1 = Employee("Zara", 2000)
"创建 Employee 类的第二个对象"
emp2 = Employee("Manni", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount
\end{lstlisting}

执行以上代码输出结果如下：
\begin{lstlisting}[language=Python]
Name :  Zara ,Salary:  2000
Name :  Manni ,Salary:  5000
Total Employee 2
\end{lstlisting}

可以添加，删除，修改类的属性，如下所示：
\begin{lstlisting}[language=Python]
emp1.age = 7  # 添加一个 'age' 属性
emp1.age = 8  # 修改 'age' 属性
del emp1.age  # 删除 'age' 属性
\end{lstlisting}

也可以使用以下函数的方式来访问属性：
\begin{itemize}
\item getattr(obj, name[, default])：访问对象的属性。
\item hasattr(obj,name) ：检查是否存在一个属性。
\item setattr(obj,name,value) ：设置一个属性。如果属性不存在，会创建一个新属性。
\item delattr(obj, name) ：删除属性。
\end{itemize}

\begin{lstlisting}[language=Python]
hasattr(emp1, 'age')    # 如果存在 'age' 属性返回 True。
getattr(emp1, 'age')    # 返回 'age' 属性的值
setattr(emp1, 'age', 8) # 添加属性 'age' 值为 8
delattr(empl, 'age')    # 删除属性 'age'
\end{lstlisting}



\subsubsection{Python内置类属性}
\begin{itemize}
\item \_\_dict\_\_ ： 类的属性（包含一个字典，由类的数据属性组成）；
\item \_\_doc\_\_ ：类的文档字符串；
\item \_\_name\_\_：类名；
\item \_\_module\_\_：类定义所在的模块（类的全名是'\_\_main\_\_.className'，如果类位于一个导入模块mymod中，那么className.\_\_module\_\_ 等于 mymod）；
\item \_\_bases\_\_ ：类的所有父类构成元素（包含了以个由所有父类组成的元组）。
\end{itemize}
Python内置类属性调用实例如下：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

class Employee:
   '所有员工的基类'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary

print "Employee.__doc__:", Employee.__doc__
print "Employee.__name__:", Employee.__name__
print "Employee.__module__:", Employee.__module__
print "Employee.__bases__:", Employee.__bases__
print "Employee.__dict__:", Employee.__dict__
\end{lstlisting}
执行以上代码输出结果如下：
\begin{lstlisting}[language=Python]
Employee.__doc__: 所有员工的基类
Employee.__name__: Employee
Employee.__module__: __main__
Employee.__bases__: ()
Employee.__dict__: {'__module__': '__main__', 'displayCount': <function displayCount at 0x10a939c80>, 'empCount': 0, 'displayEmployee': <function displayEmployee at 0x10a93caa0>, '__doc__': '\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb', '__init__': <function __init__ at 0x10a939578>}
\end{lstlisting}



\subsubsection{Python对象销毁(垃圾回收)}
同Java语言一样，Python使用了引用计数这一简单技术来追踪内存中的对象。在Python内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是"立即"的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。
\begin{lstlisting}[language=Python]
a = 40      # 创建对象  <40>
b = a       # 增加引用， <40> 的计数
c = [b]     # 增加引用.  <40> 的计数

del a       # 减少引用 <40> 的计数
b = 100     # 减少引用 <40> 的计数
c[0] = -1   # 减少引用 <40> 的计数
\end{lstlisting}

垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。

实例

析构函数 \_\_del\_\_ ，\_\_del\_\_在对象消逝的时候被调用，当对象不再被使用时，\_\_del\_\_方法运行：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

class Point:
   def __init( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print class_name, "destroyed"

pt1 = Point()
pt2 = pt1
pt3 = pt1
print id(pt1), id(pt2), id(pt3) # 打印对象的id
del pt1
del pt2
del pt3
\end{lstlisting}
实例运行结果如下：
\begin{lstlisting}[language=Python]
3083401324 3083401324 3083401324
Point destroyed
\end{lstlisting}
注意：通常需要在单独的文件中定义一个类。



\subsubsection{类的继承}
面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。继承完全可以理解成类之间的类型和子类型关系。

需要注意的地方：继承语法 class 派生类名（基类名）：//... 基类名写作括号里，基本类是在类定义的时候，在元组之中指明的。

在python中继承中的一些特点：
\begin{itemize}
\item 1：在继承中基类的构造（\_\_init\_\_()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。
\item 2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数
\item 3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。
\end{itemize}
如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" 。

语法：

派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：
\begin{lstlisting}[language=Python]
class SubClassName (ParentClass1[, ParentClass2, ...]):
   'Optional class documentation string'
   class_suite
\end{lstlisting}

实例：

\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

class Parent:        # 定义父类
   parentAttr = 100
   def __init__(self):
      print "调用父类构造函数"

   def parentMethod(self):
      print '调用父类方法'

   def setAttr(self, attr):
      Parent.parentAttr = attr

   def getAttr(self):
      print "父类属性 :", Parent.parentAttr

class Child(Parent): # 定义子类
   def __init__(self):
      print "调用子类构造方法"

   def childMethod(self):
      print '调用子类方法 child method'

c = Child()          # 实例化子类
c.childMethod()      # 调用子类的方法
c.parentMethod()     # 调用父类方法
c.setAttr(200)       # 再次调用父类的方法
c.getAttr()          # 再次调用父类的方法
\end{lstlisting}

以上代码执行结果如下：
\begin{lstlisting}[language=Python]
调用子类构造方法
调用子类方法 child method
调用父类方法
父类属性 : 200
\end{lstlisting}

可以继承多个类
\begin{lstlisting}[language=Python]
class A:        # 定义类 A
.....

class B:         # 定义类 B
.....

class C(A, B):   # 继承类 A 和 B
.....
\end{lstlisting}

可以使用issubclass()或者isinstance()方法来检测：
\begin{itemize}
\item issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup)；
\item isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。
\end{itemize}



\subsubsection{方法重写}
如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法：

实例：
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

class Parent:        # 定义父类
   def myMethod(self):
      print '调用父类方法'

class Child(Parent): # 定义子类
   def myMethod(self):
      print '调用子类方法'

c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
\end{lstlisting}

执行以上代码输出结果如下：
\begin{lstlisting}[language=Python]
调用子类方法
\end{lstlisting}



\subsubsection{基础重载方法}
下表列出了一些通用的功能，可以在自己的类重写：

\begin{itemize}
\item \_\_init\_\_ ( self [,args...] )：构造函数。简单的调用方法：obj = className(args)

\item  \_\_del\_\_( self ) ：析构方法，删除一个对象。简单的调用方法 : dell obj

\item	\_\_repr\_\_( self )：转化为供解释器读取的形式。简单的调用方法 : repr(obj)

\item	\_\_str\_\_( self )：用于将值转化为适于人阅读的形式。简单的调用方法 : str(obj)

\item	\_\_cmp\_\_( self, x )：对象比较。简单的调用方法 : cmp(obj, x)
\end{itemize}



\subsubsection{运算符重载}
Python同样支持运算符重载，实例如下：
\begin{lstlisting}[language=Python]
#!/usr/bin/python

class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b

   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print v1 + v2
\end{lstlisting}
以上代码执行结果如下所示：
\begin{lstlisting}[language=Python]
Vector(7,8)
\end{lstlisting}



\subsubsection{类属性与方法}
\begin{itemize}
\item 类的私有属性，\_\_private\_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.\_\_private\_attrs。

\item 类的方法，在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self，且为第一个参数

\item 类的私有方法，\_\_private\_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 slef.\_\_private\_methods
\end{itemize}

实例
\begin{lstlisting}[language=Python]
#coding=utf-8
#!/usr/bin/python

class JustCounter:
	__secretCount = 0  # 私有变量
	publicCount = 0    # 公开变量

	def count(self):
		self.__secretCount += 1
		self.publicCount += 1
		print self.__secretCount

counter = JustCounter()
counter.count()
counter.count()
print counter.publicCount
print counter.__secretCount  # 报错，实例不能访问私有变量
\end{lstlisting}

Python 通过改变名称来包含类名：
\begin{lstlisting}[language=Python]
1
2
2
Traceback (most recent call last):
  File "test.py", line 17, in <module>
    print counter.__secretCount  # 报错，实例不能访问私有变量
AttributeError: JustCounter instance has no attribute '__secretCount'
\end{lstlisting}

Python不允许实例化的类访问私有数据，但你可以使用 object.\_className\_\_attrName 访问属性，将如下代码替换以上代码的最后一行代码：
\begin{lstlisting}[language=Python]
.........................
print counter._JustCounter__secretCount
\end{lstlisting}

执行以上代码，执行结果如下：
\begin{lstlisting}[language=Python]
1
2
2
2
\end{lstlisting}


\section{模块学习}
\subsection{optparse模块}
Python 有两个内建的模块用于处理命令行参数：
一个是 getopt，《Deep in python》一书中也有提到，只能简单处理 命令行参数；
另一个是 optparse，它功能强大，而且易于使用，可以方便地生成标准的、符合Unix/Posix 规范的命令行说明。

简单流程

首先，必须 import OptionParser 类，创建一个 OptionParser 对象：
\begin{lstlisting}[language=Python]
from optparse import OptionParser  
parser = OptionParser() 
\end{lstlisting}

然后，使用 add\_option 来定义命令行参数：
\begin{lstlisting}[language=Python]
parser.add_option("-f", "--file", action = "store", type = "string", dest = "fileName")
\end{lstlisting}

add\_option()参数说明：

\begin{itemize}
\item short option string: 为第一个参数，表示option的缩写，例如-f;
\item long option string: 为第二个参数，表示option的全拼，例如--file;
\end{itemize}
后面的参数皆为命名参数，命名参数为可选参数;
\begin{itemize}
\item
action=: 表示对此option的处理方式，默认值为store，表示存储option的值到解析后的options对象的成员中。action还可以有其他的值：对于bool值，使用store\_true来默认存储true，使用store\_false来默认存储false，store\_const用来存储const设置的值到此option，append表示增加option的参数到list中，此时此option是一个list，可能包含多个值，count表示对counter增加一，callback表示调用指定的函数。所有的action值如下：
store + store\_true + store\_false + store\_const + append + count + callback
\item
type=:表示此option的值的类型，默认为string，可以指定为string,int,choice, float andcomplex；
\item 
dest=：表示此option在经过optionparser解析后的options对象中成员的名字，默认使用long option string；
\item 
default=:表示比option的默认值；
\item 
metavar=:表示显示到help中option的默认值（显示到help的时候并不是default）；
\item 
const=:当action为store\_const的时候，需要设置此值；
\item 
choices=:当设置type为choices时，需要设置此值；
\end{itemize}



\subsection{os模块}
一、os模块概述

Python os模块包含普遍的操作系统功能。如果你希望你的程序能够与平台无关的话，这个模块是尤为重要的。(一语中的)

二、常用方法

1、os.name

输出字符串指示正在使用的平台。如果是window 则用“nt”表示，对于Linux/Unix用户，它是“posix”。

2、os.getcwd()

函数得到当前工作目录，即当前Python脚本工作的目录路径。

3、os.listdir()

返回指定目录下的所有文件和目录名。
\begin{lstlisting}[language=Python]
>>> os.listdir(os.getcwd())
['Django', 'DLLs', 'Doc', 'include', 'Lib', 'libs', 'LICENSE.txt', 'MySQL-python-wininst.log', 'NEWS.txt', 'PIL-wininst.log', 'python.exe', 'pythonw.exe', 'README.txt', 'RemoveMySQL-python.exe', 'RemovePIL.exe', 'Removesetuptools.exe', 'Scripts', 'setuptools-wininst.log', 'tcl', 'Tools', 'w9xpopen.exe']
>>> 
\end{lstlisting}

4、os.remove()

删除一个文件。

5、os.system()

运行shell命令。
\begin{lstlisting}[language=Python]
>>> os.system('dir')
or
>>> os.system('cmd') #启动dos
\end{lstlisting}

6、os.sep 可以取代操作系统特定的路径分割符。

7、os.linesep字符串给出当前平台使用的行终止符
\begin{lstlisting}[language=Python]
>>> os.linesep
'\r\n'            #Windows使用'\r\n'，Linux使用'\n'而Mac使用'\r'。
>>> os.sep
'\\'              #Windows
>>> 
\end{lstlisting}

8、os.path.split()

函数返回一个路径的目录名和文件名
\begin{lstlisting}[language=Python]
>>> os.path.split('C:\\Python25\\abc.txt')
('C:\\Python25', 'abc.txt')
\end{lstlisting}

9、os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。
\begin{lstlisting}[language=Python]
>>> os.path.isdir(os.getcwd())
True
>>> os.path.isfile('a.txt')
False
\end{lstlisting}

10、os.path.exists()函数用来检验给出的路径是否真地存在
\begin{lstlisting}[language=Python]
>>> os.path.exists('C:\\Python25\\abc.txt')
False
>>> os.path.exists('C:\\Python25')
True
>>> 
\end{lstlisting}

11、os.path.abspath(name):获得绝对路径

12、os.path.normpath(path):规范path字符串形式

13、os.path.getsize(name):获得文件大小，如果name是目录返回0L

14、os.path.splitext():分离文件名与扩展名
\begin{lstlisting}[language=Python]
>>> os.path.splitext('a.txt')
('a', '.txt')
\end{lstlisting}

15、os.path.join(path,name):连接目录与文件名或目录
\begin{lstlisting}[language=Python]
>>> os.path.join('c:\\Python','a.txt')
'c:\\Python\\a.txt'
>>> os.path.join('c:\\Python','f1')
'c:\\Python\\f1'
>>> 
\end{lstlisting}

16、os.path.basename(path):返回文件名
\begin{lstlisting}[language=Python]
>>> os.path.basename('a.txt')
'a.txt'
>>> os.path.basename('c:\\Python\\a.txt')
'a.txt'
>>> 
\end{lstlisting}

17、os.path.dirname(path):返回文件路径
\begin{lstlisting}[language=Python]
>>> os.path.dirname('c:\\Python\\a.txt')
'c:\\Python'
\end{lstlisting}



\subsection{sys模块}
（1）sys.argv
很多人会想，我如何给我的程序在外部传递参数呢？这个，就可以实现。如：
\begin{lstlisting}[language=Python]
Tesy.py
Import sys
Print sys.argv[number]
\end{lstlisting}
一般情况下，number为0是这个脚本的名字，1，2…则为命令行下传递的参数，如：

Test.py脚本内容：
\begin{lstlisting}[language=Python]
import sys
 
print sys.argv[0]
print sys.argv[1]
print sys.argv[2]
print sys.argv[3]
\end{lstlisting}
那么
\begin{lstlisting}[language=Python]
[root@databak scripts]# python test.py arg1 arg2 arg3
test.py
arg1
arg2
arg3
\end{lstlisting}

一个有用的实例：
\begin{lstlisting}[language=Python]
#!/usr/bin/env python

import sys

if len(sys.argv) == 3:
	ftype = sys.argv[1]
	fname =  sys.argv[2]
else:
	print " Claculates the average of 2DES time-domain outputs."
	print " USAGE: aver filetype filename"
	print "    eg: aver rp fort.71"
	sys.exit(2)

print ftype
print fname
\end{lstlisting}


（2） sys.exit(n)
执行至主程序的末尾时,解释器会自动退出. 但是如果需要中途退出程序, 你可以调用sys.exit 函数, 它带有一个可选的整数参数返回给调用它的程序. 这意味着你可以在主程序中捕获对sys.exit 的调用。（注：0是正常退出，其他为不正常，可抛异常事件供捕获!）


(3)sys.path
大家对模块都有一定了解吧？大家在使用模块的某一个功能前，是不是需要导入呢？答案是需要。那import,\_\_import\_\_命令就不用提干嘛的了吧。那大家在执行import module\_name的时候，python内部发生了什么呢？简单的说，就是搜索module\_name。根据sys.path的路径来搜索module.name
\begin{lstlisting}[language=Python]
>>> sys.path
['', '/usr/local/lib/python24.zip', '/usr/local/lib/python2.4', '/usr/local/lib/python2.4/plat-freebsd4', '/usr/local/lib/python2.4/lib-tk', '/usr/local/lib/python2.4/lib-dynload', '/usr/local/lib/python2.4/site-packages']
\end{lstlisting}
大家以后写好的模块就可以放到上面的某一个目录下，便可以正确搜索到了。当然大家也可以添加自己的模块路径：
\begin{lstlisting}[language=Python]
Sys.path.append(“mine module path”)
\end{lstlisting}



\section{Python 内置特殊函数}
这些函数很具python特性，可以让代码更加简洁。

1、filter(function, sequence)：
\begin{lstlisting}[language=Python]
str = ['a', 'b','c', 'd']

def fun1(s): return s if s != 'a' else None

ret = filter(fun1, str)

print ret

## ['b', 'c', 'd']
\end{lstlisting}
对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）返回。

可以看作是过滤函数。


 2、map(function, sequence) 
\begin{lstlisting}[language=Python]
str = ['a', 'b','c', 'd'] 

def fun2(s): return s + ".txt"

ret = map(fun2, str)

print ret

## ['a.txt', 'b.txt', 'c.txt', 'd.txt']
\end{lstlisting}
对sequence中的item依次执行function(item)，见执行结果组成一个List返回：

map也支持多个sequence，这就要求function也支持相应数量的参数输入：
\begin{lstlisting}[language=Python]
def add(x, y): return x+y 
 print map(add, range(10), range(10)) 
##[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
\end{lstlisting}

3、reduce(function, sequence, starting\_value)：def add1(x,y): return x + y
\begin{lstlisting}[language=Python]
print reduce(add1, range(1, 100))

print reduce(add1, range(1, 100), 20)

## 4950 （注：1+2+...+99）
## 4970 （注：1+2+...+99+20）

对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和： 
\end{lstlisting}

4、lambda：
\begin{lstlisting}[language=Python]
g = lambda s: s + ".fsh"

print g("haha")

print (lambda x: x * 2) (3)

## haha.fsh

## 6
\end{lstlisting}
这是Python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似与C语言中的宏，这些叫做lambda的函数.



\section{Python 数值计算库NumPy和SciPy}
标准的Python中用列表(list)保存一组值，可以用来当作数组使用。但由于列表的元素可以是任何对象，因此列表中所保存的是对象的指针。这样为了保存一个简单的列表[1,2,3]，需要有三个指针和三个整数对象。对于数值运算来说这种结构显然比较浪费内存和CPU计算时间。

此外Python还提供了array模块，它所提供的array对象和列表不同，能直接保存数值，和C语言的一维数组类似。但是由于它不支持多维数组，也没有各种运算函数，因此也不适合做数值运算。

NumPy为Python提供了快速的多维数组处理的能力，而SciPy则在NumPy基础上添加了众多的科学计算所需的各种工具包，有了这两个库，Python就有几乎和Matlab一样的处理数据和计算的能力了。

NumPy和SciPy官方网址：\url{http://www.numpy.org}、\url{http://www.scipy.org}

NumPy为Python带来了真正的多维数组功能，并且提供了丰富的函数库处理这些数组。它将常用的数学函数都进行数组化，使得这些数学函数能够直接对数组进行操作，将本来需要在Python级别进行的循环，放到C语言的运算中，明显地提高了程序的运算速度。

SciPy的核心计算部分都是一些久经考验的Fortran数值计算库，例如：

\begin{itemize}
\item
线性代数使用LAPACK库
\item
快速傅立叶变换使用FFTPACK库
\item
常微分方程求解使用ODEPACK库
\item
非线性方程组求解以及最小值求解等使用MINPACK库
\end{itemize}



\subsection{文件存取}
savetxt() 和 loadtxt() 可以读写保存一维和二维数组的文本文件，如CSV格式的文本文件。

\subsubsection{说明文档}
\url{http://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html}

\verb|numpy.savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n', header='', footer='', comments='# ')|

Save an array to a text file.

Paramters:
\begin{itemize}
\item
fname : filename or file handle\\
If the filename ends in .gz, the file is automatically saved in compressed gzip format. loadtxt understands gzipped files transparently.
\item
X : array\_like\\
Data to be saved to a text file.
\item
fmt : str or sequence of strs, optional
A single format (\%10.5f), a sequence of formats, or a multi-format string, e.g. ‘Iteration \%d – \%10.5f’, in which case delimiter is ignored. For complex X, the legal options for fmt are:
	\begin{itemize}
	\item
	a single specifier, fmt=’\%.4e’, resulting in numbers formatted\\
	like ‘ (\%s+\%sj)’ \% (fmt, fmt)
	\item
	a full string specifying every real and imaginary part, e.g.\\
	‘\%.4e \%+.4j \%.4e \%+.4j \%.4e \%+.4j’ for 3 columns
	\item
	a list of specifiers, one per column - in this case, the real\\
	and imaginary part must have separate specifiers, e.g. [‘\%.3e + \%.3ej’, ‘(\%.15e\%+.15ej)’] for 2 columns
\end{itemize}
\item
delimiter : str, optional\\
String or character separating columns.
\item
newline : str, optional\\
String or character separating lines.
New in version 1.5.0.
\item
header : str, optional\\
String that will be written at the beginning of the file.
New in version 1.7.0.
\item
footer : str, optional\\
String that will be written at the end of the file.
New in version 1.7.0.
\item
comments : str, optional\\
String that will be prepended to the header and footer strings, to mark them as comments. Default: ‘\# ‘, as expected by e.g. numpy.loadtxt.
New in version 1.7.0.
\end{itemize}


\url{http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html}

\verb|numpy.loadtxt(fname, dtype=<type 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0)|

Load data from a text file.Each row in the text file must have the same number of values.

Parameters:
\begin{itemize}
\item
fname : file or str\\
File, filename, or generator to read. If the filename extension is .gz or .bz2, the file is first decompressed. Note that generators should return byte strings for Python 3k.
\item
dtype : data-type, optional\\
Data-type of the resulting array; default: float. If this is a record data-type, the resulting array will be 1-dimensional, and each row will be interpreted as an element of the array. In this case, the number of columns used must match the number of fields in the data-type.
\item
comments : str, optional\\
The character used to indicate the start of a comment; default: ‘\#’.
\item
delimiter : str, optional\\
The string used to separate values. By default, this is any whitespace.
\item
converters : dict, optional\\
A dictionary mapping column number to a function that will convert that column to a float. E.g., if column 0 is a date string: converters = {0: datestr2num}. Converters can also be used to provide a default value for missing data (but see also genfromtxt): converters = {3: lambda s: float(s.strip() or 0)}. Default: None.
\item
skiprows : int, optional\\
Skip the first skiprows lines; default: 0.
\item
usecols : sequence, optional\\
Which columns to read, with 0 being the first. For example, usecols = (1,4,5) will extract the 2nd, 5th and 6th columns. The default, None, results in all columns being read.
\item
unpack : bool, optional\\
If True, the returned array is transposed, so that arguments may be unpacked using x, y, z = loadtxt(...). When used with a record data-type, arrays are returned for each field. Default is False.
\item
ndmin : int, optional\\
The returned array will have at least ndmin dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.
New in version 1.6.0.
\end{itemize}

Returns: out : ndarray, Data read from the text file.


\subsubsection{单一数据类型的情况}
（1）默认格式。默认按照\%.18e格式保存数值，以空格分隔。
\begin{lstlisting}[language=Python]
>>> import numpy as np
>>> a = np.arange(0,12,0.5).reshape(4,-1)
>>> np.savetxt("a.txt",a)
>>> np.loadtxt("a.txt")
array([[  0. ,   0.5,   1. ,   1.5,   2. ,   2.5],
       [  3. ,   3.5,   4. ,   4.5,   5. ,   5.5],
       [  6. ,   6.5,   7. ,   7.5,   8. ,   8.5],
       [  9. ,   9.5,  10. ,  10.5,  11. ,  11.5]])
\end{lstlisting}

（2）自定义格式。
\begin{lstlisting}[language=Python]
>>> import numpy as np
>>> a = np.arange(0,12,0.5).reshape(4,-1)
>>> np.savetxt("a.txt", a, fmt="%d", delimiter=",")
#保存为整数，以逗号分隔
>>> np.loadtxt("a.txt", delimiter=",")
# 读入的时候也需要指定逗号分隔
array([[  0.,   0.,   1.,   1.,   2.,   2.],
       [  3.,   3.,   4.,   4.,   5.,   5.],
       [  6.,   6.,   7.,   7.,   8.,   8.],
       [  9.,   9.,  10.,  10.,  11.,  11.]])
\end{lstlisting}


\subsubsection{混合数据类型的情况}
有的 CSV 文件中除了保存数值之外，还保存了一些说明文字。例如第一行和第一列通常为行名和列名。如果需要忽略 CSV 文件的第一行和第一列，可以先将文件读为字符串数组，然后取出需要的部分，转换为数值数值。例如对于下面的CSV数据文件：
\begin{lstlisting}[language=Python]
姓名,年龄,体重,身高
张三,30,75,165
李四,45,60,170
王五,15,30,120
\end{lstlisting}
可以采用如下程序读入其中的数值部分：
\begin{lstlisting}[language=Python]
>>> import numpy as np
>>> tmp = np.loadtxt("test.csv", dtype=np.str, delimiter=",")
>>> data = tmp[1:,1:].astype(np.float)
>>> data
array([[  30.,   75.,  165.],
       [  45.,   60.,  170.],
       [  15.,   30.,  120.]])
\end{lstlisting}










