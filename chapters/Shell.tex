\chapter{Shell \& Shell Script}
Shell的学习与Linux的学习是密切相关的，要学Linux必须学Shell。
\section{什么是Shell}
Shell 是用户用来控制计算机的一个接口。与现代普通用户常见的计算机操作界面——图形化界面不同的是，这里指的是纯文字界面，称为命令行界面。只要能够操作应用程序的接口都能够称为壳程序。狭义的壳程序指的是命令行界面的软件，如常见的 bash 等。 广义的壳程序则是图形接口的软件，因为图形接口其实也是操作各种应用程序来调用核心工作。命令行界面控制计算机高效、稳定、准确，适合程序员用户。

Shell程序的出现是跟操作系统设计思想密切相关的。对于Linux系统，管理整个计算机硬件的是操作系统的核心 (Kernel)，这个核心是需要被保护。因为操作系统其实是一组软件，只不过这组软件控制着整个硬件与管理系统的活动监测。 如果这组软件能被用户随意的操作，若使用者应用不当，将会使得整个系统崩溃。因为操作系统管理的就是整个硬件功能！ 所以不能够随便被一些没有管理能力的终端用户随意使用。

但是我们总是需要让用户操作系统的，所以就有了在操作系统上面发展的应用程序。用户可以透过应
用程序来指挥核心， 让核心达成我们所需要的硬件任务。应用程序是在最外层的，就如同鸡蛋的外壳一样，所以被称为壳程序 (Shell) 。通过Shell可以调用其他独立的应用程序，即通过Shell来操作其他应用程序来指挥核心完成工作，所以说Shell 是用户用来控制计算机的一个接口。用户通过Shell将指令传递给Kernel，Kernel再来控制硬件完成工作。



\section{常见的Shell}
简单点理解，Shell就是系统跟计算机硬件交互时使用的中间介质，它只是系统的一个工具。实际上，在Shell和计算机硬件之间还有一层东西那就是系统内核了。打个比方，如果把计算机硬件比作一个人的躯体，而系统内核则是人的大脑，至于Shell，把它比作人的五官似乎更加贴切些。回到计算机上来，用户直接面对的不是计算机硬件而是Shell，用户把指令告诉Shell，然后Shell再传输给系统内核，接着内核再去支配计算机硬件去执行各种操作。

Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本。Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器。
\begin{itemize}
\item bash

bash是Linux标准默认的Shell，本教程也基于bash讲解。bash由Brian Fox和Chet Ramey共同完成，是BourneAgain Shell的缩写，内部命令一共有40个。它基于Bourne shell，吸收了C shell和Korn shell的一些特性。bash完全兼容sh，也就是说，用sh写的脚本可以不加修改的在bash中执行。

\item sh

sh 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的Shell。

\item ash

ash shell 是由Kenneth Almquist编写的，Linux中占用系统资源最少的一个小Shell，它只包含24个内部命令，因而使用起来很不方便。

\item csh

csh 是Linux比较大的内核，它由以William Joy为代表的共计47位作者编成，共有52个内部命令。该Shell其实是指向/bin/tcsh这样的一个Shell，也就是说，csh其实就是tcsh。

\item ksh

ksh 是Korn shell的缩写，由Eric Gisin编写，共有42条内部命令。该Shell最大的优点是几乎和商业发行版的ksh完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。
\end{itemize}



\section{Shell的特性}
\begin{itemize}
\item \textbf{记录命令历史}

\qquad 我们敲过的命令，Linux 是会有记录的，预设可以记录1000条历史命令。这些命令保存在用户的 home 目录中的  .bash\_history 文件中。有一点需要知道的是，只有当用户正常退出当前 Shell 时，在当前 Shell 中运行的命令才会保存至  .bash\_history 文件中。

\qquad 与命令历史有关的有一个有意思的字符那就是``!''了。常用的有这么几个应用：

（1）!! （连续两``!''），表示执行上一条指令；

（2）!n（这里的n是数字），表示执行命令历史中第n条指令，例如``!100''表示执行命令历史中第100个命令；

（3）!字符串（字符串大于等于1），例如，!ta，表示执行命令历史中最近一次以ta为开头的指令。

\item \textbf{命令和文件名补全}

\qquad 按tab键，它可以帮你补全一个指令，也可以帮你补全一个路径或者一个文件名。连续按两次tab键，系统则会把所有的指令或者文件名都列出来。

（1）tab 接在一串命令的第一个字的后面为命令补全；

（2）tab 接在一串命令的第二个字以后面则为文件或路径补全。

\item \textbf{命令别名配置功能——alias}

\qquad 输入 alias会看到目前系统预设的命令别名有哪些。自定义别名形如：

\verb|alias lm='ls -al'|

这样lm 会等于 ls -al 这样的一个功能，即显示这个目录底下的所有文件 (包含隐藏档) 及所有的文件属性。
这个就是bash所特有的功能之一了。我们可以通过alias把一个常用的并且很长的指令别名一个简洁易记的指令。如果不想用了，还可以用unalias解除别名功能。需要注意的是命令的别名在Shell注销后就会失效，如果要保留，就得写入Shell的配置文件。

\item \textbf{通配符}

\qquad 除了完整的字符串之外， bash 还支持许多的通配符来帮助用户查询与命令下达。 举例来说，想要知道 /usr/bin 底下有多少以 X 为开头的文件吗？使用：ls -l /usr/bin/X* 就能够知道。此外，还有其他可供利用的通配符， 这些都能够加快使用者的操作。
\end{itemize}



\section{Bash Shell的内建命令}
 为了方便 Shell 的操作， Bash 内建了很多命令。对于如何知道命令是外部命令还是内建在Bash当中，可以利用type命令，其格式如下：
 
 \verb|type [-tpa] name|

选项与参数：
\begin{itemize}
\item 不加任何选项与参数时，type 会显示出 name 是外部命令还是 Bash 内建命令；
\item -t：当加入 -t 参数时，type 会将 name 以底下这些字眼显示出它的意义：
	\begin{itemize}
	\item  file    ：表示为外部命令；
       \item alias   ：表示该命令为命令别名所配置的名称；
      \item builtin ：表示该命令为 bash 内建的命令功能。
	\end{itemize}
\item -p  ：如果后面接的 name 为外部命令时，才会显示完整文件名；
\item -a  ：会由 PATH 变量定义的路径中，将所有含 name 的命令都列出来，包含 alias。	
\end{itemize}



\section{Bash的进站与欢迎信息}
在终端机接口 (tty1$\sim$tty6) 登陆的时候，会有几行提示的字符串，那就是进站画面。这些字符串存储在/etc/issue文件里面。例如，
\begin{lstlisting}[language=sh]
xuan@x:~$ cat /etc/issue
Ubuntu 14.04.2 LTS \n \l

xuan@x~$ 
\end{lstlisting}

issue 内的各代码意义

\verb|\d| 本地端时间的日期；

\verb|\l| 显示第几个终端机接口；

\verb|\m| 显示硬件的等级 (i386/i486/i586/i686...)；

\verb|\n |显示主机的网络名称；

\verb|\o |显示 domain name；

\verb|\r |操作系统的版本 (相当于 uname -r)

\verb|\t |显示本地端时间的时间；

\verb|\s |操作系统的名称；

\verb|\v |操作系统的版本。




\section{Shell的配置文件}
\subsection{login与non-login Shell}
login Shell与non-login Shell的区别在于有没有login：
\begin{itemize}
\item login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，由 tty1$\sim$tty6 登陆，需要输入用户的账号与密码，此时取得的 bash 就称为“ login shell ”；

\item non-login shell：取得 bash 接口的方法不需要重复登陆的举动，举例来说，

\qquad（1）以 X window 登陆 Linux 后， 再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入账号与密码，那个 bash的环境就称为 “non-login shell”。

\qquad （2）在原本的 bash环境下再次调用 bash 这个命令，同样的也没有输入账号密码， 那第二个 bash (子程序) 也是 “non-login shell” 。
\end{itemize}

在这两种取得bash的情况中，bash读取的配置文件不一样。一般说来，login Shell读取的配置文件是：
\begin{itemize}
\item \verb|/etc/profile|：这是系统整体的配置，最好不要修改这个文件；

\item \verb|~/.bash_profile| 或 \verb|~/.bash_login| 或 \verb|~/.profile|：属于用户个人配置文件，要改自己的数据，就写入这里。
\end{itemize}


\subsection{login Shell}
\subsubsection{/etc/profile}
/etc/profile，login Shell读取的配置文件。这个配置文件可以利用用户ID (UID) 来决定很多重要的变量数据， 这也是每个用户login取得 bash 时一定会读取的配置文件。 所以如果想要帮所有用户配置整体环境，那就是修改这里。不过，没事还是不要随便改这个文件。这个文件配置的变量主要有：
\begin{itemize}
\item PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录；
\item MAIL：依据账号配置好使用者的 mailbox 到 /var/spool/mail/账号名；
\item USER：根据用户的账号配置此一变量内容；
\item HOSTNAME：依据主机的 hostname 命令决定此一变量内容；
\item HISTSIZE：历史命令记录笔数。
\end{itemize}

/etc/profile 还会调用外部的配置文件，如：/etc/profile.d/*.sh，即只要用户具有r的权限，那么在 /etc/profile.d/ 这个目录内且扩展名为 .sh的文件就会被 /etc/profile调用。如果需要帮所有用户配置一些共享的命令别名时， 可以在这个目录底下自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可。这样的机制让我们的 bash 操作接口变的非常友善。


\subsubsection{$\sim$/.bash\_profile、$\sim$/.bash\_login和$\sim$/.profile}
对于login Shell，bash 在读完了整体环境配置的 /etc/profile 并藉此调用其他配置文件后，接下来则是会读取用户的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件主要有三个，依序分别是：
\begin{enumerate}
\item \verb|~/.bash_profile|
\item \verb|~/.bash_login|
\item \verb|~/.profile|
\end{enumerate}

其实 bash 的 login shell 配置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 \verb|~/.bash_profile|存在，那么其他两个文件不论有无存在，都不会被读取。 如果 \verb|~/.bash_profile|不存在才会去读取 \verb|~/.bash_login|，而前两者都不存在才会读取 \verb|~/.profile| 的意思。 会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。

一般保证login Shell也读取用户配置信息，通常加入
\begin{verbatim}
 # Get the aliases and functions
      if [ -f ~/.bashrc ]; then
             ~/.bashrc
      fi
\end{verbatim}


\subsection{non-login Shell: $\sim$/.bashrc}
当取得 non-login shell 时，该 bash 配置文件仅会读取 \verb|~/.bashrc| 而已！


\subsection{其他相关配置文件}
还有一些配置文件可能会影响到bash 操作的：
\begin{itemize}
\item \verb|~/.bash_history|

\qquad 默认情况下， 我们的历史命令就记录在这里。而这个文件能够记录几笔数据，则与 HISTFILESIZE 这个变量有关啊。每次登陆 bash 后，bash 会先读取这个文件，将所有的历史命令读入内存， 因此，当我们登陆 bash 后就可以查知上次使用过哪些命令。

\item \verb|~/.bash_logout|

\qquad 这个文件则记录了，当我注销 bash 后，系统再帮我做完什么动作后才离开，的意思。 可以去读取一下这个文件的内容，默认的情况下，注销时， bash 只是帮我们清掉屏幕的信息而已。 不过，我们也可以将一些备份或者是其他认为重要的工作写在这个文件中 （例如清空缓存盘）， 那么当我们离开 Linux 的时候，就可以解决一些烦人的事情。

\item \verb|/etc/man.config|

\qquad 这个文件乍看之下好像跟 bash 没相关性，但是对于系统管理员来说， 却也是很重要的一个文件。这个文件的内容规范了使用 man 的时候， man page 的路径到哪里去寻找。所以说的简单一点，这个文件规定使用 man命令的时候，该去哪里查看数据的路径配置。

\qquad 那么什么时候要来修改这个文件呢？如果是以 tarball 的方式来安装数据，那么 man page 可能会放置在 /usr/local/softpackage/man 里头，那个 softpackage 是软件名称， 这个时候就得以手动的方式将该路径加到 /etc/man.config 里头，否则使用 man 的时候就会找不到相关的说明档。

\qquad 事实上，这个文件内最重要的其实是 MANPATH 这个变量配置。 我们搜寻 man page 时，会依据 MANPATH 的路径去分别搜寻。另外，要注意的是， 这个文件在各大不同版本 Linux distributions 中，名称都不太相同，例如 CentOS 用的是 /etc/man.config ，而 SuSE 用的则是 /etc/manpath.config ， 可以利用 [tab] 按键来进行文件名的补齐。
\end{itemize}


\section{通配符与特殊符号}
在 bash 的操作环境中还有一个非常有用的功能，那就是通配符 (wildcard) ，利用 bash 处理数据就更方便了。底下列出一些常用的通配符：
\begin{itemize}
\item \verb|*|：代表 “0 个到无穷多个”任意字符；

\item \verb|?|：代表“一定有一个”任意字符；

\item \verb|[ ]|：同样代表“一定有一个在括号内”的字符(非任意字符)。例如 [abcd] 代表“一定有一个字符， 可能是 a、b、 c、 d 这四个任何一个”；再说个例子\verb|*[0]|和\verb|*[0]*|，前者是寻找结尾为0的任意文件，后者则是寻找包含0的任意文件，把各自符号的意义套入就能分析出来；

\item \verb|[ - ]|：若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的；

\item \verb|[^ ]|：若中括号内的第一个字符为指数符号 “\verb|^|” ，那表示“反向选择”，例如 \verb|[^abc]| 代表 一定有一个字符，只要是非 a、 b、 c 的其他字符就接受的意思。
\end{itemize}

下面列出的则是bash 环境中的特殊符号：
\begin{itemize}
\item \verb|#|：批注符号，这个最常被使用在 script 当中，视为说明，在后的数据均不运行；
\item \verb|\|：跳脱符号，将“特殊字符或通配符”还原成一般字符；
\item\verb|||：	管线 (pipe)，分隔两个管线命令的界定；
\item \verb|;|：连续命令下达分隔符，连续性命令的界定 (注意！与管道符并不相同)；
\item \verb|~|：用户的家目录；
\item \verb|$|：取用变量前导符，亦即是变量之前需要加的变量取代值；
\item \verb|&|：工作控制 (job control)，将命令变成背景下工作；
\item \verb|!|：逻辑运算意义上的“非” （not） 的意思；
\item \verb|/|：目录符号，路径分隔的符号；
\item \verb|>, >>|：数据流重导向，输出导向，分别是“取代”与“累加”；
\item \verb|<, <<|：数据流重导向，输入导向 ；
\item \verb|' '|：单引号，不具有变量置换的功能；
\item \verb|" "|	：具有变量置换的功能；
\item \verb|` `|	：两个“\verb|`| ”中间为可以先运行的命令，亦可使用 “\verb|$( )|”；
\item \verb|( )|	：在中间为子 shell 的起始与结束；
\item \verb|{ }|	：在中间为命令区块的组合。
\end{itemize}
所以文档名尽量不要使用到上述的字符。这里只是简单介绍，更详细的介绍参见相关章节。


\subsection{``～''后缀的文件}
当我们编辑文本文件时，保存后经常发现多了个后面带个``～''的同样名字的隐藏文件。这是前一个版本的系统自动备份的文件，万一发生错误和其他意外时，保留这些文件还是有一定作用的。如果觉得没必要，可以通过设置更改。

\begin{itemize}
\item
对于编辑器 gedit：编辑=>首选项=>编辑器，把保存文件时备份选项去掉就可以了；

\item
vim的话可以在其配置文件.vimrc中取消设置backup文件：\verb|set nobackup|。
\end{itemize}

\subsection{反斜杠}
因为命令太长， 于是可以就利用“\verb| \[Enter]| ”来将 [Enter] 这个按键“跳脱！”开来，让 [Enter] 按键不再具有“开始运行”的功能，好让命令可以继续在下一行输入。 需要特别留意， [Enter] 按键是紧接着反斜杠 (\verb|\|) 的，两者中间没有其他字符。 因为 \verb|\| 仅跳脱“紧接着的下一个字符”而已！所以，万一写成： \verb*|\ [Enter]|，亦即 [Enter] 与反斜杠中间有一个空格时，则 \verb|\| 跳脱的是“空格键”而不是 [Enter] 按键，这个地方请再仔细的看一遍！很重要！

如果顺利跳脱 [Enter] 后，下一行最前面就会主动出现 > 的符号， 就可以继续输入命令。也就是说，那个 > 是系统自动出现的，不需要输入。









\section{什么是Shell脚本}
% http://c.biancheng.net/cpp/shell/
计算机语言从执行过程的角度可以分为编译型语言和解释型语言（当然还有其他语言，如HTML、\LaTeX 标记语言等），但无论哪种语言，所有的语言编写出来的程序执行时要解释成计算机代码。
\begin{itemize}
\item 编译型语言：编写完程序后直接通过编译器转换程计算机代码生成可执行文件，以后每次执行时就不用进行转换，直接执行可执行文件即可。

很多传统的程序设计语言，例Fortran、Ada、Pascal、C、C++和Java，都是编译型语言。这类语言需要预先将我们写好的源代码(source code)转换成目标代码(object code)，这个过程被称作“编译”。运行程序时，直接读取目标代码(object code)。由于编译后的目标代码(object code)非常接近计算机底层，因此执行效率很高，这是编译型语言的优点。但是，由于编译型语言多半运作于底层，所处理的是字节、整数、浮点数或是其他机器层级的对象，往往实现一个简单的功能需要大量复杂的代码。例如，在C++里，就很难进行“将一个目录里所有的文件复制到另一个目录中”之类的简单操作。

\item 解释型语言：编写完成后不用转换成计算机代码，而是在每次执行的时候再进行代码转换工作，脚本语言的好处是源文件能够直接进行修改，直接使用文本编辑器就能够打开。

解释型语言也被称作“脚本语言”。执行这类程序时，解释器(interpreter)需要读取我们编写的源代码(source code)，并将其转换成目标代码(object code)，再由计算机运行。因为每次执行程序都多了编译的过程，因此效率有所下降。使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象；缺点是它们的效率通常不如编译型语言。不过权衡之下，通常使用脚本编程还是值得的：花一个小时写成的简单脚本，同样的功能用C或C++来编写实现，可能需要两天，而且一般来说，脚本执行的速度已经够快了，快到足以让人忽略它性能上的问题。脚本编程语言的例子有awk、Perl、Python、Ruby与Shell。
\end{itemize}

Shell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。

它虽然不是Unix/Linux系统内核的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。因此，对于用户来说，Shell是最重要的实用程序，深入了解和熟练掌握Shell的特性极其使用方法，是用好Unix/Linux系统的关键。可以说，Shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。

Shell有两种执行命令的方式：
\begin{itemize}
\item 交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。
\item 批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。
\end{itemize}

Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。


说白了，Shell脚本就是一些命令的集合。举个例子，我想实现这样的操作：

1）进入到/tmp/目录；

2）列出当前目录中所有的文件名；

3）把所有当前的文件拷贝到/home/xuan目录下；

4）删除当前目录下所有的文件。

简单的4步在Shell窗口中需要你敲4次命令，按4次回车。这样是不是很麻烦？当然这4步操作非常简单，如果是更加复杂的命令设置需要几十次操作呢？那样的话一次一次敲键盘会很麻烦。所以不妨把所有的操作都记录到一个文档中，然后去调用文档中的命令，这样一步操作就可以完成。其实这个文档呢就是Shell脚本了，只是这个Shell脚本有它特殊的格式。

Shell脚本能帮助我们很方便的去管理服务器，因为我们可以指定一个任务计划定时去执行某一个Shell脚本实现我们想要需求。这对于Linux系统管理员来说是一件非常值得自豪的事情。现在的139邮箱很好用，发邮件的同时还可以发一条邮件通知的短信给用户，利用这点，我们就可以在我们的Linux服务器上部署监控的Shell脚本，比如网卡流量有异常了或者服务器web服务器停止了就可以发一封邮件给管理员，同时发送给管理员一个报警短信这样可以让我们及时的知道服务器出问题了。

有一个问题需要约定一下，凡是自定义的脚本建议放到/usr/local/sbin/目录下，这样做的目的是，一来可以更好的管理文档；二来以后接管你的管理员都知道自定义脚本放在哪里，方便维护。

Shell脚本通常都是以.sh 为后缀名的，这个并不是说不带.sh这个脚本就不能执行，只是大家的一个习惯而已。所以，以后你发现了.sh为后缀的文件那么它一定会是一个Shell脚本了。

“\verb|#|”表示注释，在前面讲过的。后面跟一些该脚本的相关注释内容以及作者和创建日期或者版本等等。当然这些注释并非必须的，如果你懒的很，可以省略掉，但是笔者不建议省略。因为随着你工作时间的增加，你写的shell脚本也会越来越多，如果有一天你回头查看你写的某个脚本时，很有可能忘记该脚本是用来干什么的以及什么时候写的。所以写上注释是有必要的。另外系统管理员并非你一个，如果是其他管理员查看你的脚本，他看不懂岂不是很郁闷。

该脚本再往下面则为要运行的命令了。

例如：test.sh
\begin{lstlisting}[language=sh]
#!/bin/bash
## This is my first shell script.
## Wrote by Aming 2011-05-20

date
echo "Hello World."
\end{lstlisting}



\subsection{Shell 脚本的第一行}
“\verb|#!|” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。

目前研发送测的shell脚本中主要有以下两种方式：

(1) \verb|#!/bin/sh|

(2) \verb|#!/bin/bash|

以上两种方式有什么区别？对于脚本的实际运行会产生什么不同的影响吗？

脚本test.sh内容：
\begin{lstlisting}[language=sh]
#!/bin/sh
source pcy.sh #pcy.sh并不存在
echo hello
\end{lstlisting}
执行./test.sh，屏幕输出为：

\verb|./test.sh: line 2: pcy.sh: No such file or directory|

由此可见，在\verb|#!/bin/sh|的情况下，source不成功，不会运行source后面的代码。修改test.sh脚本的第一行，变为\verb|#!/bin/bash|，再次执行./test.sh，屏幕输出为：
\begin{verbatim}
./test.sh: line 2: pcy.sh: No such file or directory

hello
\end{verbatim}

由此可见，在\verb|#!/bin/bash|的情况下，虽然source不成功，但是还是运行了source后面的echo语句。
为什么会有这样的区别呢？junru同学作了解释：

1. sh一般设成bash的软链
\begin{verbatim}
[work@zjm-testing-app46 cy]$ ll /bin/sh

lrwxrwxrwx 1 root root 4 Nov 13 2006 /bin/sh -> bash
\end{verbatim}

2. 在一般的linux系统当中（如redhat），使用sh调用执行脚本相当于打开了bash的POSIX标准模式

3. 也就是说 /bin/sh 相当于 /bin/bash --posix

所以，sh跟bash的区别，实际上就是bash有没有开启posix模式的区别。so，可以预想的是，如果第一行写成 \verb|#!/bin/bash --posix|，那么脚本执行效果跟\verb|#!/bin/sh|是一样的（遵循posix的特定规范，有可能就包括这样的规范：“当某行代码出错时，不继续往下解释”）。



\subsection{Shell脚本的执行}
Shell脚本的执行很简单，有两种方法。

（1）作为解释器参数，即直接运行解释器，其参数就是Shell脚本的文件名，例如

\verb|sh test.sh|\qquad 或更严格的 \qquad \verb|/bin/sh test.sh|

这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。另外使用sh命令去执行一个shell脚本的时候是可以加-x选项来查看这个脚本执行过程的，这样有利于我们调试这个脚本哪里出了问题。例如，\verb|sh -x test.sh|，则有
\begin{verbatim}
+date
Fri May 2o 11:24:53 CST 2011
+echo 'Hello World'
Hello World
\end{verbatim}

（2）作为可执行程序。

（a）在脚本所在目录下，首先使脚本具有执行权限，有两种方法：
\begin{enumerate}
\item 命令操作：\verb|chmod +x ./test.sh|；
\item 图形化操作：选中脚本test.sh右键勾选可以执行选项。
\end{enumerate}

（b）然后执行程序：\verb|./test.sh|

注意，一定要写成./test.sh，而不是test.sh。这里的“./”实质指的是相对路径，即当前路径下。如果test.sh在/bin目录下，当然也可以采用绝大路径来运行即“/bin/test.sh”，只不过相对路径更简便些。运行其它二进制的程序也一样，直接写test.sh，Linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin、 /sbin、 /usr/bin、/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。

通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。

这里的"系统"，其实就是shell这个应用程序，但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。


\subsection{Shell脚本的注释}
以“\#”开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个\#号。如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个\#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。


\subsection{Shell脚本的文件包含}
像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。

Shell 中包含脚本可以使用：
\verb|. filename|

或

\verb|source filename|

两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。

例如，创建两个脚本，一个是被调用脚本 subscript.sh，内容如下：

\verb|url="http://see.xidian.edu.cn/cpp/view/2738.html"|

一个是主文件 main.sh，内容如下：
\begin{lstlisting}[language=sh]
#!/bin/bash
. ./subscript.sh
echo $url
\end{lstlisting}
执行脚本：
\begin{verbatim}
$chomd +x main.sh
./main.sh
http://see.xidian.edu.cn/cpp/view/2738.html
$
\end{verbatim}
注意：被包含脚本不需要有执行权限。








\section{输入输出重定向}
Unix 命令默认从标准输入设备(stdin)获取输入，将结果输出到标准输出设备(stdout)显示。一般情况下，标准输入设备就是键盘，标准输出设备就是终端，即显示器。


\subsection{输出重定向}
命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。

命令输出重定向的语法为：

\verb|$ command > file|

这样，输出到显示器的内容就可以被重定向到文件。

例如，下面的命令在显示器上不会看到任何输出：
\begin{lstlisting}[language=sh]
$ who > users
\end{lstlisting}
打开 users 文件，可以看到下面的内容：
\begin{verbatim}
$ cat users
oko         tty01   Sep 12 07:30
ai          tty15   Sep 12 13:32
ruth        tty21   Sep 12 10:10
pat         tty24   Sep 12 13:07
steve       tty25   Sep 12 13:03
$
\end{verbatim}
输出重定向会覆盖文件内容，请看下面的例子：
\begin{verbatim}
$ echo line 1 > users
$ cat users
line 1
$
\end{verbatim}
如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾，例如：
\begin{verbatim}
$ echo line 2 >> users
$ cat users
line 1
line 2
$
\end{verbatim}


\subsection{输入重定向}
和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：

\verb|$ command < file|

这样，本来需要从键盘获取输入的命令会转移到文件读取内容。

注意：输出重定向是大于号(>)，输入重定向是小于号(<)。

例如，计算 users 文件中的行数，可以使用下面的命令：
\begin{verbatim}
$ wc -l users
2 users
$
\end{verbatim}

也可以将输入重定向到 users 文件：
\begin{verbatim}
$ wc -l < users
2
$
\end{verbatim}
注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。


\subsection{重定向深入讲解}
一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：
\begin{itemize}
\item
 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据；
 \item
标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据；
\item
标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。
\end{itemize}
默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。

如果希望 stderr 重定向到 file，可以这样写：

\verb|$command 2 > file|

如果希望 stderr 追加到 file 文件末尾，可以这样写：

\verb|$command 2 >> file|

其中数字2表示标准错误文件（stderr）。

如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：
\verb|$command > file 2>&1|

或

\verb|$command >> file 2>&1|

如果希望对 stdin 和 stdout 都重定向，可以这样写：
\verb|$command < file1 >file2|

command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。


全部可用的重定向命令列表

\begin{center}
\begin{tabular}{l|l}
命令&	说明\\
\hline
command > file	&将输出重定向到 file\\
command < file	&将输入重定向到 file\\
command \verb|>>| file	&将输出以追加的方式重定向到 file\\
n > file	&将文件描述符为 n 的文件重定向到 file\\
n \verb|>>| file	&将文件描述符为 n 的文件以追加的方式重定向到 file\\
n >\& m	&将输出文件 m 和 n 合并\\
n <\& m	&将输入文件 m 和 n 合并\\
\verb|<<| tag	&将开始标记 tag 和结束标记 tag 之间的内容作为输入
\end{tabular}
\end{center}


\subsection{Here Document}
Here Document 目前没有统一的翻译，这里暂译为“嵌入文档”。Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下：
\begin{verbatim}
command << delimiter
    document
delimiter
\end{verbatim}
它的作用是将两个 delimiter （界定符）之间的内容(document) 作为输入传递给 command。

注意：
\begin{itemize}
\item
结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进；
\item
开始的delimiter前后的空格会被忽略掉。
\end{itemize}

下面的例子，通过 wc -l 命令计算 document 的行数：
\begin{verbatim}
$wc -l << EOF
    This is a simple lookup program
    for good (and bad) restaurants
    in Cape Town.
EOF
3
$
\end{verbatim}
其中EOF是end of file的缩写。

也可以 将 Here Document 用在脚本中，例如：
\begin{lstlisting}[language=sh]
#!/bin/bash

cat << EOF
This is a simple lookup program
for good (and bad) restaurants
in Cape Town.
EOF
\end{lstlisting}
运行结果：
\begin{verbatim}
This is a simple lookup program
for good (and bad) restaurants
in Cape Town.
\end{verbatim}

下面的脚本通过 vi 编辑器将 document 保存到 test.txt 文件：
\begin{lstlisting}[language=sh]
#!/bin/sh

filename=test.txt
vi $filename <<EndOfCommands
i
This file was created automatically from
a shell script
^[
ZZ
EndOfCommands
\end{lstlisting}
运行脚本：
\begin{verbatim}
$ sh test.sh
Vim: Warning: Input is not from a terminal
$
\end{verbatim}
打开 test.txt，可以看到下面的内容：
\begin{verbatim}
$ cat test.txt
This file was created automatically from
a shell script
$
\end{verbatim}


\subsection{/dev/null文件}
如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

\verb|$ command > /dev/null|

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

\verb|$ command > /dev/null 2>&1|






\section{变量}
\subsection{定义变量}
定义变量时，变量名不加美元符号（\$），如

\verb|variableName="value"|

注意，\textbf{等号两边不能直接接空格符}，即\verb*|variableName = "value"|是错误的，这可能和我们熟悉的所有编程语言都不一样。总的来说，变量名的命名须遵循如下规则：
\begin{itemize}
\item 首个字符必须为字母（a-z，A-Z）；
\item 中间不能有空格，可以使用下划线（\_）；
\item 不能使用标点符号；
\item 不能使用bash里的关键字（可用help命令查看保留关键字）；
\item 通常大写字符为系统默认变量，自行配置变量可以使用小写字符。
\end{itemize}

变量定义举例：
\begin{lstlisting}[language=sh]
myUrl="http://see.xidian.edu.cn/cpp/linux/"
myNum=100
\end{lstlisting}


\subsection{使用变量}
使用一个定义过的变量，只要在变量名前面加美元符号（\$）即可，如：
\begin{lstlisting}[language=sh]
your_name="mozhiyan"
echo $your_name
echo ${your_name}
\end{lstlisting}
变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：
\begin{lstlisting}[language=sh]
for skill in Ada Coffe Action Java 
do
    echo "I am good at ${skill}Script"
done
\end{lstlisting}
如果不给skill变量加花括号，写成\verb|echo "I am good at $skillScript"|，解释器就会把\verb|$skillScript|当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。推荐给所有变量加上花括号，这是个好的编程习惯。需要注意的是，还有个类似的表达，\verb|$()|，这是命令替换的一种表达。


\subsection{重新定义变量}
已定义的变量，可以被重新定义，如：
\begin{lstlisting}[language=sh]
myUrl="http://see.xidian.edu.cn/cpp/linux/"
echo ${myUrl}

myUrl="http://see.xidian.edu.cn/cpp/shell/"
echo ${myUrl}
\end{lstlisting}
这样写是合法的，但注意，第二次赋值的时候不能写 \$myUrl="http://see.xidian.edu.cn/cpp/shell/"，使用变量的时候才加美元符（\$）。


\subsection{只读变量}
使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

下面的例子尝试更改只读变量，结果报错：
\begin{lstlisting}[language=sh]
#!/bin/bash

myUrl="http://see.xidian.edu.cn/cpp/shell/"
readonly myUrl
myUrl="http://see.xidian.edu.cn/cpp/danpianji/"
\end{lstlisting}
运行脚本，结果如下：

\verb|/bin/sh: NAME: This variable is read only.|


\subsection{删除变量}
使用 unset 命令可以删除变量。语法：

\verb|unset variable_name|

变量被删除后不能再次使用；unset 命令不能删除只读变量。

举个例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

myUrl="http://see.xidian.edu.cn/cpp/u/xitong/"
unset myUrl
echo $myUrl
\end{lstlisting}
上面的脚本没有任何输出。


\subsection{变量类型}
运行Shell时，会同时存在三种变量：

1) 局部变量

局部变量在脚本或命令中定义，仅在当前Shell实例中有效，其他Shell启动的程序不能访问局部变量。

2) 环境变量

所有的程序，包括Shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候Shell脚本也可以定义环境变量。

3) Shell变量

Shell变量是由Shell程序设置的特殊变量。Shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了Shell的正常运行。

\textbf{详见环境变量相关章节。}


\subsection{特殊变量}
（1）特殊变量列表

\begin{center}
{\small
\begin{tabular}{l|l}
变量&含义\\
\$0 &当前脚本的文件名\\
\$n	&传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是\$1，第二个参数是\$2。\\
\$\#&	传递给脚本或函数的参数个数。\\
\$*	&传递给脚本或函数的所有参数。\\
\$@ &	传递给脚本或函数的所有参数。被双引号(`` ")包含时，与 \$* 稍有不同，下面将会讲到。\\
\$?	&上个命令的退出状态，或函数的返回值。\\
\$\$&	当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。\\
\end{tabular}
}
\end{center}

例如，\$ 表示当前Shell进程的ID，即pid，看下面的代码：
\begin{lstlisting}[language=sh]
$echo $$
\end{lstlisting}
运行结果

3433


（2）命令行参数

运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 \$n 表示，例如，\$1 表示第一个参数，\$2 表示第二个参数，依次类推。

请看下面的脚本：
\begin{lstlisting}[language=sh]
#!/bin/bash

echo "File Name: $0"
echo "First Parameter : $1"
echo "First Parameter : $2"
echo "Quoted Values: $@"
echo "Quoted Values: $*"
echo "Total Number of Parameters : $#"
\end{lstlisting}

运行：\verb|./test.sh Zara Ali|

运行结果为：
\begin{verbatim}
File Name : ./test.sh
First Parameter : Zara
Second Parameter : Ali
Quoted Values: Zara Ali
Quoted Values: Zara Ali
Total Number of Parameters : 2
\end{verbatim}


（3）\$* 和 \$@ 的区别

\$* 和 \$@ 都表示传递给函数或脚本的所有参数，不被双引号(`` ")包含时，形式是一样的，都以`` \$1" ``\$2" … ``\$n" 的形式输出所有参数。

但是当它们被双引号(`` ")包含时，``\$*" 会将所有的参数作为一个整体，以``\$1 \$2 … \$n"的形式输出所有参数；``\$@" 会将各个参数分开，以``\$1" ``\$2" … ``\$n" 的形式输出所有参数。


（4）退出状态

\$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。

退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。

不过，也有一些命令返回其他值，表示不同类型的错误。

\$? 也可以表示函数的返回值，后续将会讲解。



\subsection{键盘读取变量}
要读取来自键盘输入的变量，就要用到 read 命令了。其使用格式如下：

\verb|read [-pt] variable|
选项与参数：
\begin{itemize}
\item -p  ：后面可以接提示字符！
\item -t  ：后面可以接等待的“秒数”。这个比较有趣，不会一直等待使用者。
\end{itemize}

read 之后不加任何参数，直接加上变量名称，那么底下就会主动出现一个空白行等待你的输入。 如果加上 -t 后面接秒数，那么在设置的时间之内没有任何动作时， 该命令就会自动略过了。如果是加上 -p ，在输入的光标前就会有比较多可以用的提示字符给我们参考， 在命令的下达里面，比较美观。参见下面这个例子： 
\begin{lstlisting}[language=sh]
xuan@www:~$ read atest
This is an apple
xuan@www:~$ echo $atest
This is an apple
xuan@www:~$ read -p "Please keyin your name: " -t 30 named
Please keyin your name: xuan
xuan@www:~$ echo $named 
xuan
xuan@www:~$ 
\end{lstlisting}



\subsection{变量声明}
declare 或 typeset 是一样的功能，就是在声明变量的类型。如果使用 declare 后面并没有接任何参数，那么 Bash 就会主动的将所有的变量名称与内容通通叫出来，就好像使用 set 一样。 declare的命令格式如下：

\verb|declare [-aixr] variable|

选项与参数：
\begin{itemize}
\item -a  ：将后面名为 variable 的变量定义成为数组 (array) 类型；
\item -i  ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型；
\item -x  ：用法与 export 一样，就是将后面的自定义变量variable 变成环境变量；
\item +x ：撤销环境变量，将将后面的环境变量variable 变成自定义变量；
\item -r  ：将变量配置成为 readonly 类型，该变量不可被更改内容，也不能 unset；
\item -p ：列出后面变量的类型。
\end{itemize}

具体用法参考鸟哥的例子：
\begin{lstlisting}[language=sh]
范例一：让变量 sum 进行 100+300+50 的加总结果
[root@www ~]# sum=100+300+50
[root@www ~]# echo $sum
100+300+50  <==咦！怎么没有帮我计算加总？因为这是文字型态的变量属性啊！
[root@www ~]# declare -i sum=100+300+50
[root@www ~]# echo $sum
450         <==瞭乎？？

范例二：将 sum 变成环境变量
[root@www ~]# declare -x sum
[root@www ~]# export | grep sum
declare -ix sum="450"  <==果然出现了！包括有 i 与 x 的宣告！

范例三：让 sum 变成只读属性，不可更动！
[root@www ~]# declare -r sum
[root@www ~]# sum=tesgting
-bash: sum: readonly variable  <==老天爷～不能改这个变量了！

范例四：让 sum 变成自定义变量吧！
[root@www ~]# declare +x sum  <== 将 - 变成 + 可以进行『取消』动作
[root@www ~]# declare -p sum  <== -p 可以单独列出变量的类型
declare -ir sum="450" <== 看吧！只剩下 i, r 的类型，不具有 x 啰！
\end{lstlisting}

在默认的情况底下， bash 对于变量有几个基本的定义：
\begin{itemize}
\item 变量类型默认为『字符串』，所以若不指定变量类型，则 1+2 为一个『字符串』而不是『计算式』。 所以上述第一个运行的结果才会出现那个情况的；
\item bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0；
\end{itemize}



\section{替换}
\subsection{转义字符}
如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。

举个例子：
\begin{lstlisting}[language=sh]
#!/bin/bash

a=10
echo -e "Value of a is $a \n"
\end{lstlisting}
运行结果：

\verb|Value of a is 10|

这里 -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出：

\verb|Value of a is 10\n|

下面的转义字符都可以用在 echo 中：
\begin{center}
\begin{tabular}{l|l}
转义字符&	含义\\
\verb|\\|	&反斜杠\\
\verb|\a|	&警报，响铃\\
\verb|\b|	&退格（删除键）\\
\verb|\f|	&换页(FF)，将当前位置移到下页开头\\
\verb|\n|	&换行\\
\verb|\r|	&回车\\
\verb|\t|	&水平制表符（tab键） \\
\verb|\v|	&垂直制表符
\end{tabular}
\end{center}
可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。


\subsection{命令替换}
命令替换是指Shell可以先执行命令，将输出结果替换该命令。命令替换的一般作用是抽取一个命令的输出，然后使用=操作赋值到一个变量供以后使用。

命令替换有两种语法：

\verb|`command`| 或 \verb|$(command)|

注意是反引号，不是单引号，这个键位于 Esc 键下方。

命令由于简单，使用\verb|``|没问题。如果命令中有转义就麻烦了， 因为\verb|\|也是``的转义符，不注意的情况下出现不是预想的结果，而且还很难查出bug。\verb|$()|就不一样了， 你在命令行上任何一条正确的命令都可以用\verb|$()|。还有\verb|$()|支持多重嵌套，使用更加灵活，如
\verb|fatherpath=$(dirname $(pwd))|。

下面的例子中，将命令执行结果保存在变量中：
\begin{lstlisting}[language=sh]
#!/bin/bash

DATE=`date`
echo "Date is $DATE"

USERS=`who | wc -l`
echo "Logged in user are $USERS"

UP=`date ; uptime`
echo "Uptime is $UP"
\end{lstlisting}

运行结果：
\begin{verbatim}
Date is Thu Jul  2 03:59:57 MST 2009
Logged in user are 1
Uptime is Thu Jul  2 03:59:57 MST 2009
03:59:57 up 20 days, 14:03,  1 user,  load avg: 0.13, 0.07, 0.15
\end{verbatim}


\subsection{变量替换}
变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值。可以使用的变量替换形式：
\begin{itemize}
\item \verb|${var}|：	变量本来的值

\item \verb|${var:-word}|	：如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。

\item \verb|${var:=word}|：	如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。
\item \verb|${var:?message}|：	如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。

\item \verb|${var:+word}	|：如果变量 var 被定义，那么返回 word，但不改变 var 的值。
\end{itemize}




\section{数组}
Bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。


\subsection{定义数组}
在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：

\verb|array_name=(value1 ... valuen)|

例如：
\begin{lstlisting}[language=sh]
array_name=(value0 value1 value2 value3)
\end{lstlisting}
或者
\begin{lstlisting}[language=sh]
array_name=(
value0
value1
value2
value3
)
\end{lstlisting}

还可以单独定义数组的各个分量：
\begin{lstlisting}[language=sh]
array_name[0]=value0
array_name[1]=value1
array_name[2]=value2
\end{lstlisting}


\subsection{读取数组}
读取数组元素值的一般格式是：

\verb|  ${array_name[index]}|

例如：
\begin{lstlisting}[language=sh]
valuen=${array_name[2]}
\end{lstlisting}

举个例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"
echo "First Index: ${NAME[0]}"
echo "Second Index: ${NAME[1]}"
\end{lstlisting}
运行脚本，输出：
\begin{verbatim}
$./test.sh
First Index: Zara
Second Index: Qadir
\end{verbatim}
使用@ 或 * 可以获取数组中的所有元素，例如：
\begin{lstlisting}[language=sh]
${array_name[*]}
${array_name[@]}
\end{lstlisting}
举个例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"
echo "First Method: ${NAME[*]}"
echo "Second Method: ${NAME[@]}"
\end{lstlisting}
运行脚本，输出：
\begin{verbatim}
$./test.sh
First Method: Zara Qadir Mahnaz Ayan Daisy
Second Method: Zara Qadir Mahnaz Ayan Daisy
\end{verbatim}


\subsection{获取数组的长度}
获取数组长度的方法与获取字符串长度的方法相同，例如：
\begin{lstlisting}[language=sh]
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
\end{lstlisting}






\section{运算符}
Bash 支持很多运算符，包括算术运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。


\subsection{算术运算}
原生Bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

例如，两个数相加：
\begin{lstlisting}[language=sh]
#!/bin/bash

val=`expr 2 + 2`
echo "Total value : $val"
\end{lstlisting}
运行脚本输出：

\verb|Total value : 4|

注意：
\begin{itemize}
\item 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样；

\item 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。
\end{itemize}

再看一个使用算术运算符的例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

a=10
b=20
val=`expr $a + $b`
echo "a + b : $val"

val=`expr $a - $b`
echo "a - b : $val"

val=`expr $a \* $b`
echo "a * b : $val"

val=`expr $b / $a`
echo "b / a : $val"

val=`expr $b % $a`
echo "b % a : $val"

if [ $a == $b ]
then
   echo "a is equal to b"
fi

if [ $a != $b ]
then
   echo "a is not equal to b"
fi
\end{lstlisting}
运行结果：
\begin{verbatim}
a + b : 30
a - b : -10
a * b : 200
b / a : 2
b % a : 0
a is not equal to b
\end{verbatim}

注意：
\begin{itemize}
\item 乘号(*)前边必须加反斜杠(\verb|\|)才能实现乘法运算；
\item if...then...fi 是条件语句，后续将会讲解。
\end{itemize}

算术运算符列表
\begin{center}
\begin{tabular}{c|c|c}
运算符&	说明	&举例\\
\hline
+	&加法	&\verb|`expr $a + $b`| 结果为 30。\\
-	&减法	&\verb|`expr $a - $b` |结果为 10。\\
*	&乘法	&\verb|`expr $a \* $b`| 结果为  200。\\
/	&除法	&\verb|`expr $b / $a` |结果为 2。\\
\%	&取余	&\verb|`expr $b % $a` |结果为 0。\\
=	&赋值	&\verb| a=$|b 将把变量 b 的值赋给 a。\\
==	&相等&用于比较两个数字，相同则返回 true。	\verb|[ $a == $b ] |返回 false。\\
!=	&不相等&用于比较两个数字，不相同则返回 true。\verb|[ $a != $b ]| 返回 true。
\end{tabular}
\end{center}
注意：条件表达式要放在方括号之间，并且要有空格，例如\verb| [$a==$b]| 是错误的，必须写成 \verb|[ $a == $b ]|。


\subsection{关系运算符}
关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

先来看一个关系运算符的例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

a=10
b=20
if [ $a -eq $b ]
then
   echo "$a -eq $b : a is equal to b"
else
   echo "$a -eq $b: a is not equal to b"
fi

if [ $a -ne $b ]
then
   echo "$a -ne $b: a is not equal to b"
else
   echo "$a -ne $b : a is equal to b"
fi

if [ $a -gt $b ]
then
   echo "$a -gt $b: a is greater than b"
else
   echo "$a -gt $b: a is not greater than b"
fi

if [ $a -lt $b ]
then
   echo "$a -lt $b: a is less than b"
else
   echo "$a -lt $b: a is not less than b"
fi

if [ $a -ge $b ]
then
   echo "$a -ge $b: a is greater or  equal to b"
else
   echo "$a -ge $b: a is not greater or equal to b"
fi

if [ $a -le $b ]
then
   echo "$a -le $b: a is less or  equal to b"
else
   echo "$a -le $b: a is not less or equal to b"
fi
\end{lstlisting}
运行结果：
\begin{verbatim}
10 -eq 20: a is not equal to b
10 -ne 20: a is not equal to b
10 -gt 20: a is not greater than b
10 -lt 20: a is less than b
10 -ge 20: a is not greater or equal to b
10 -le 20: a is less or  equal to b
\end{verbatim}

关系运算符列表
\begin{center}
\begin{tabular}{c|c|c}
运算符&	说明	&举例\\
\hline
-eq	&检测两个数是否相等，相等返回 true	&\verb|[ $a -eq $b ]| 返回 true\\
-ne	&检测两个数是否相等，不相等返回 true	&\verb|[ $a -ne $b ]| 返回 true\\
-gt	&检测左边的数是否大于右边的，如果是，则返回 true&	\verb|[ $a -gt $b ]| 返回 false\\
-lt	&检测左边的数是否小于右边的，如果是，则返回 true	&\verb|[ $a -lt $b ]| 返回 true\\
-ge	&检测左边的数是否大等于右边的，如果是，则返回 true&\verb|[ $a -ge $b ]| 返回 false\\
-le	&检测左边的数是否小于等于右边的，如果是，则返回 true&\verb|[ $a -le $b ]| 返回 true
\end{tabular}
\end{center}


\subsection{布尔运算符}
先来看一个布尔运算符的例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

a=10
b=20

if [ $a != $b ]
then
   echo "$a != $b : a is not equal to b"
else
   echo "$a != $b: a is equal to b"
fi

if [ $a -lt 100 -a $b -gt 15 ]
then
   echo "$a -lt 100 -a $b -gt 15 : returns true"
else
   echo "$a -lt 100 -a $b -gt 15 : returns false"
fi

if [ $a -lt 100 -o $b -gt 100 ]
then
   echo "$a -lt 100 -o $b -gt 100 : returns true"
else
   echo "$a -lt 100 -o $b -gt 100 : returns false"
fi

if [ $a -lt 5 -o $b -gt 100 ]
then
   echo "$a -lt 100 -o $b -gt 100 : returns true"
else
   echo "$a -lt 100 -o $b -gt 100 : returns false"
fi
\end{lstlisting}
运行结果：
\begin{verbatim}
10 != 20 : a is not equal to b
10 -lt 100 -a 20 -gt 15 : returns true
10 -lt 100 -o 20 -gt 100 : returns true
10 -lt 5 -o 20 -gt 100 : returns false
\end{verbatim}

布尔运算符列表
{\small
\begin{center}
\begin{tabular}{c|c|c}
运算符&	说明	&举例\\
\hline
!	&非运算，表达式为 true 则返回 false，否则返回 true&	\verb|[ ! false ]| 返回 true\\
-o	&或运算，有一个表达式为 true 则返回 true&	\verb|[ $a -lt 20 -o $b -gt 100 ]| 返回 true\\
-a	&与运算，两个表达式都为 true 才返回 true&	\verb|[ $a -lt 20 -a $b -gt 100 ]| 返回 false
\end{tabular}
\end{center}}


\subsection{字符串运算符}
先来看一个例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

a="abc"
b="efg"

if [ $a = $b ]
then
   echo "$a = $b : a is equal to b"
else
   echo "$a = $b: a is not equal to b"
fi

if [ $a != $b ]
then
   echo "$a != $b : a is not equal to b"
else
   echo "$a != $b: a is equal to b"
fi

if [ -z $a ]
then
   echo "-z $a : string length is zero"
else
   echo "-z $a : string length is not zero"
fi

if [ -n $a ]
then
   echo "-n $a : string length is not zero"
else
   echo "-n $a : string length is zero"
fi

if [ $a ]
then
   echo "$a : string is not empty"
else
   echo "$a : string is empty"
fi
\end{lstlisting}
运行结果：
\begin{verbatim}
abc = efg: a is not equal to b
abc != efg : a is not equal to b
-z abc : string length is not zero
-n abc : string length is not zero
abc : string is not empty
\end{verbatim}

字符串运算符列表
\begin{center}
\begin{tabular}{c|c|c}
运算符&	说明	&举例\\
\hline
=	&检测两个字符串是否相等，相等返回 true &	\verb|[ $a = $b ] |返回 false\\
!=	&检测两个字符串是否相等，不相等返回 true&	\verb|[ $a != $b ] |返回 true\\
-z	&检测字符串长度是否为0，为0返回 true &     \verb|[ -z $a ]| 返回 false\\
-n	&检测字符串长度是否为0，不为0返回 true&	\verb|[ -z $a ]| 返回 true\\
str	&检测字符串是否为空，不为空返回 true&  	\verb|[ $a ]| 返回 true
\end{tabular}
\end{center}


\subsection{文件测试运算符}
文件测试运算符用于检测 Unix 文件的各种属性。

例如，变量 file 表示文件“/var/www/tutorialspoint/unix/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：
\begin{lstlisting}[language=sh]
#!/bin/sh

file="/var/www/tutorialspoint/unix/test.sh"

if [ -r $file ]
then
   echo "File has read access"
else
   echo "File does not have read access"
fi

if [ -w $file ]
then
   echo "File has write permission"
else
   echo "File does not have write permission"
fi

if [ -x $file ]
then
   echo "File has execute permission"
else
   echo "File does not have execute permission"
fi

if [ -f $file ]
then
   echo "File is an ordinary file"
else
   echo "This is sepcial file"
fi

if [ -d $file ]
then
   echo "File is a directory"
else
   echo "This is not a directory"
fi

if [ -s $file ]
then
   echo "File size is zero"
else
   echo "File size is not zero"
fi

if [ -e $file ]
then
   echo "File exists"
else
   echo "File does not exist"
fi
\end{lstlisting}
运行结果：
\begin{verbatim}
File has read access
File has write permission
File has execute permission
File is an ordinary file
This is not a directory
File size is zero
File exists
\end{verbatim}

文件测试运算符列表
{\tiny
\begin{center}
\begin{tabular}{c|c|c}
运算符&	说明	&举例\\
\hline
-b file	&检测文件是否是块设备文件，如果是，则返回 true&	\verb|[ -b $file ]| 返回 false\\
-c file	&检测文件是否是字符设备文件，如果是，则返回 true&	\verb|[ -b $file ]| 返回 false\\
-d file	&检测文件是否是目录，如果是，则返回 true&	\verb|[ -d $file ]| 返回 false\\
-f file	&检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true&	\verb|[ -f $file ]| 返回 true\\
-g file	&检测文件是否设置了 SGID 位，如果是，则返回 true&	\verb|[ -g $file ] |返回 false\\
-k file	&检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true& \verb|[ -k $file ] |返回 false\\
-p file	&检测文件是否是具名管道，如果是，则返回 true&	\verb|[ -p $file ] |返回 false\\
-u file	&检测文件是否设置了 SUID 位，如果是，则返回 true&	\verb|[ -u $file ] |返回 false\\
-r file	&检测文件是否可读，如果是，则返回 true	& \verb|[ -r $file ]| 返回 true\\
-w file	&检测文件是否可写，如果是，则返回 true	& \verb|[ -w $file ]| 返回 true\\
-x file	&检测文件是否可执行，如果是，则返回 true&	 \verb|[ -x $file ]| 返回 true\\
-s file	&检测文件是否为空（文件大小是否大于0），不为空返回 true	& \verb|[ -s $file ]| 返回 true\\
-e file	&检测文件（包括目录）是否存在，如果是，则返回 true&	\verb| [ -e $file ]| 返回 true
\end{tabular}
\end{center}}


\section{字符串}
字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。

（1）单引号
\begin{lstlisting}[language=sh]
str='this is a string'
\end{lstlisting}

单引号字符串的限制：
\begin{itemize}
\item 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
\item 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。
\end{itemize}

（2）双引号
\begin{lstlisting}[language=sh]
your_name='qinjx'
str="Hello, I know your are \"$your_name\"! \n"
\end{lstlisting}

双引号的优点：
\begin{itemize}
\item 双引号里可以有变量；
\item 双引号里可以出现转义字符
\end{itemize}

（3）拼接字符串
\begin{lstlisting}[language=sh]
your_name="qinjx"
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"

echo $greeting $greeting_1
\end{lstlisting}

（4）获取字符串长度
\begin{lstlisting}[language=sh]
string="abcd"
echo ${#string} #输出 4
\end{lstlisting}

（5）提取子字符串
\begin{lstlisting}[language=sh]
string="alibaba is a great company"
echo ${string:1:4} #输出liba
\end{lstlisting}
注意：计数从0开始。

（6）查找子字符串
\begin{lstlisting}[language=sh]
string="alibaba is a great company"
echo `expr index "$string" is`
\end{lstlisting}


\section{条件判断}
\subsection{if语句}
if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if ... else 语句：
\begin{itemize}
\item if ... then ... fi 语句；
\item if ... then ... else ... fi 语句；
\item if ... then ... elif ... then ... else ... fi 语句。
\end{itemize}

（1）if ... then ... fi 语句的语法：
\begin{verbatim}
if [ expression ]
then
   Statement(s) to be executed if expression is true
fi
\end{verbatim}

如果 expression 返回 true，then 后边的语句将会被执行；如果返回 false，不会执行任何语句。
最后必须以 fi 来结尾闭合 if，fi 就是 if 倒过来拼写。
注意：expression 和方括号([ ])之间必须有空格，否则会有语法错误。

举个例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

a=10
b=20

if [ $a == $b ]
then
   echo "a is equal to b"
fi

if [ $a != $b ]
then
   echo "a is not equal to b"
fi
\end{lstlisting}
运行结果：

\verb|a is not equal to b|

（2） if ... then ... else ... fi 语句的语法
\begin{verbatim}
if [ expression ]
then
   Statement(s) to be executed if expression is true
else
   Statement(s) to be executed if expression is not true
fi
\end{verbatim}

如果 expression 返回 true，那么 then 后边的语句将会被执行；否则，执行 else 后边的语句。

举个例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

a=10
b=20

if [ $a == $b ]
then
   echo "a is equal to b"
else
   echo "a is not equal to b"
fi
\end{lstlisting}
运行结果：

\verb|a is not equal to b|


（3）if ... then ... elif ... then ... else ... fi 语句可以对多个条件进行判断，语法为：
\begin{verbatim}
if [ expression 1 ]
then
   Statement(s) to be executed if expression 1 is true
elif [ expression 2 ]
then
   Statement(s) to be executed if expression 2 is true
elif [ expression 3 ]
then
   Statement(s) to be executed if expression 3 is true
else
   Statement(s) to be executed if no expression is true
fi
\end{verbatim}

哪一个 expression 的值为 true，就执行哪个 expression 后面的语句；如果都为 false，那么不执行任何语句。

举个例子：
\begin{lstlisting}[language=sh]
#!/bin/sh

a=10
b=20

if [ $a == $b ]
then
   echo "a is equal to b"
elif [ $a -gt $b ]
then
   echo "a is greater than b"
elif [ $a -lt $b ]
then
   echo "a is less than b"
else
   echo "None of the condition met"
fi
\end{lstlisting}
运行结果：

\verb|a is not equal to b|


（4）if语句还可以和test命令结合使用，如
\begin{lstlisting}[language=sh]
num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo 'The two numbers are equal!'
else
    echo 'The two numbers are not equal!'
fi
\end{lstlisting}
运行结果：

\verb|The two numbers are equal!|\\
test 命令用于检查某个条件是否成立，与方括号([ ])类似。

（5）if 语句也可以写成一行，以命令的方式来运行，像这样：
\begin{lstlisting}[language=sh]
if test $[2*3] -eq $[1+5]; then echo 'The two numbers are equal!'; fi;
\end{lstlisting}



\subsection{if 语句中的 -a到-z}
\begin{lstlisting}[language=sh]
[ -a FILE ] 如果 FILE 存在则为真。
[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。
[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。
[ -d FILE ] 如果 FILE 存在且是一个目录则为真。
[ -e FILE ] 如果 FILE 存在则为真。
[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。
[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。
[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。
[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。
[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。
[ -r FILE ] 如果 FILE 存在且是可读的则为真。
[ -s FILE ] 如果 FILE 存在且大小不为o则为真。
[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。
[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。
[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。
[ -x FILE ] 如果 FILE 存在且是可执行的则为真。
[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。
[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。
[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。
[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。
[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。
[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。
[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。
[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。
[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。
[ -z STRING ] “STRING” 的长度为零则为真。
[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。
[ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。
[ STRING1 != STRING2 ] 如果字符串不相等则为真。
[ STRING1 < STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。
[ STRING1 > STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。
[ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers.
\end{lstlisting}



\subsection{case 语句}
case ... esac 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构。case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：
\begin{verbatim}
case 值 in
模式1)
    command1
    command2
    command3
    ;;
模式2）
    command1
    command2
    command3
    ;;
*)
    command1
    command2
    command3
    ;;
esac
\end{verbatim}

case工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。

下面的脚本提示输入1到4，与每一种模式进行匹配：
\begin{lstlisting}[language=sh]
echo 'Input a number between 1 to 4'
echo 'Your number is:\c'
read aNum
case $aNum in
    1)  echo 'You select 1'
    ;;
    2)  echo 'You select 2'
    ;;
    3)  echo 'You select 3'
    ;;
    4)  echo 'You select 4'
    ;;
    *)  echo 'You do not select a number between 1 to 4'
    ;;
esac
\end{lstlisting}
输入不同的内容，会有不同的结果，例如：
\begin{verbatim}
Input a number between 1 to 4
Your number is:3
You select 3
\end{verbatim}
再举一个例子：
\begin{lstlisting}[language=sh]
#!/bin/bash

option="${1}"
case ${option} in
   -f) FILE="${2}"
      echo "File name is $FILE"
      ;;
   -d) DIR="${2}"
      echo "Dir name is $DIR"
      ;;
   *) 
      echo "`basename ${0}`:usage: [-f file] | [-d directory]"
      exit 1 # Command to come out of the program with status 1
      ;;
esac
\end{lstlisting}
运行结果：
\begin{verbatim}
$./test.sh
test.sh: usage: [ -f filename ] | [ -d directory ]
$ ./test.sh -f index.htm
File name is index.htm
$ ./test.sh -d unix
Dir name is unix
$
\end{verbatim}


\section{循环}
\subsection{for循环}
for循环一般格式为：
\begin{verbatim}
for 变量 in 列表
do
    command1
    command2
    ...
    commandN
done
\end{verbatim}

列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。

例如，顺序输出当前列表中的数字：
\begin{lstlisting}[language=sh]
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
\end{lstlisting}
运行结果：
\begin{verbatim}
The value is: 1
The value is: 2
The value is: 3
The value is: 4
The value is: 5
\end{verbatim}

顺序输出字符串中的字符：
\begin{lstlisting}[language=sh]
for str in 'This is a string'
do
    echo $str
done
\end{lstlisting}
运行结果：
\begin{verbatim}
This is a string
\end{verbatim}

显示主目录下以 .bash 开头的文件：
\begin{lstlisting}[language=sh]
#!/bin/bash

for FILE in $HOME/.bash*
do
   echo $FILE
done
\end{lstlisting}
运行结果：
\begin{verbatim}
/root/.bash_history
/root/.bash_logout
/root/.bash_profile
/root/.bashrc
\end{verbatim}



\subsubsection{seq命令}
seq命令用于产生从某个数到另外一个数之间的所有整数。\\
例一：
\begin{lstlisting}[language=sh]
　　 seq 1 10
\end{lstlisting}
结果是1 2 3 4 5 6 7 8 9 10\\
例二：
\begin{lstlisting}[language=sh]
　　for i in `seq 1 10`
　　do
　　echo $i
　　done
\end{lstlisting}

或者用
\begin{lstlisting}[language=sh]
　　for i in $(seq 1 10)
\end{lstlisting}
也可以。

seq的选项：
\begin{itemize}
\item \verb|-f, --format=FORMAT|: use printf style floating-point FORMAT (default: \%g)\\
-f 选项   指定格式
\begin{lstlisting}[language=sh]
seq -f"%3g" 9 11
9
10
11
\end{lstlisting}
\% 后面指定数字的位数 默认是“\%g”；\\
“\%3g”那么数字位数不足部分是空格 ；\\
sed -f“\%03g” 9 11 这样的话数字位数不足部分是0；\\
\%前面制定字符串：
\begin{lstlisting}[language=sh]
seq -f "str%03g" 9 11
str009
str010
str011
\end{lstlisting}
\item \verb|-s, --separator=STRING|: use STRING to separate numbers (default: /n)\\
-s 指定分隔符 默认是回车；\\
\verb|seq -s" " -f"str\%03g" 9 11|\\
输出结果：str009 str010 str011\\
要指定/t 做为分隔符号：\\
\verb|seq -s"`echo -e "/t"`" 9 11|

\item \verb|-w, --equal-width|:  equalize width by padding with leading zeroes\\
-w 指定输出数字同宽   不能和-f一起用 \\
\begin{lstlisting}[language=sh]
seq -w 98 101
098
099
100
101
\end{lstlisting}
输出是同宽的。
\end{itemize}




\subsection{while循环}
while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：
\begin{verbatim}
while command
do
   Statement(s) to be executed if command is true
done
\end{verbatim}
命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。

以下是一个基本的while循环，测试条件是：如果COUNTER小于5，那么返回 true。COUNTER从0开始，每次循环处理时，COUNTER加1。运行上述脚本，返回数字1到5，然后终止。
\begin{lstlisting}[language=sh]
COUNTER=0
while [ $COUNTER -lt 5 ]
do
    COUNTER='expr $COUNTER+1'
    echo $COUNTER
done
\end{lstlisting}
运行脚本，输出：
\begin{verbatim}
1
2
3
4
5
\end{verbatim}

while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。
\begin{lstlisting}[language=sh]
echo 'type <CTRL-D> to terminate'
echo -n 'enter your most liked film: '
while read FILM
do
    echo "Yeah! great film the $FILM"
done
\end{lstlisting}
运行脚本，输出类似下面：
\begin{verbatim}
type <CTRL-D> to terminate
enter your most liked film: Sound of Music
Yeah! great film the Sound of Music
\end{verbatim}


\subsection{until循环}
until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。

until 循环格式为：
\begin{verbatim}
until command
do
   Statement(s) to be executed until command is true
done
\end{verbatim}
command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。

例如，使用 until 命令输出 0 ~ 9 的数字：
\begin{lstlisting}[language=sh]
#!/bin/bash

a=0

until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done
\end{lstlisting}
运行结果：
\begin{verbatim}
0
1
2
3
4
5
6
7
8
9
\end{verbatim}


\subsection{跳出循环}
在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。


\subsubsection{break命令}
break命令允许跳出所有循环（终止执行后面的所有循环）。

下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，就要使用break命令。
\begin{lstlisting}[language=sh]
#!/bin/bash
while :
do
    echo -n "Input a number between 1 to 5: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "Your number is $aNum!"
        ;;
        *) echo "You do not select a number between 1 to 5, game is over!"
            break
        ;;
    esac
done
\end{lstlisting}
在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：
\begin{lstlisting}[language=sh]
break n
\end{lstlisting}
表示跳出第 n 层循环。

下面是一个嵌套循环的例子，如果 var1 等于 2，并且 var2 等于 0，就跳出循环：
\begin{lstlisting}[language=sh]
#!/bin/bash

for var1 in 1 2 3
do
   for var2 in 0 5
   do
      if [ $var1 -eq 2 -a $var2 -eq 0 ]
      then
         break 2
      else
         echo "$var1 $var2"
      fi
   done
done
\end{lstlisting}
如上，break 2 表示直接跳出外层循环。运行结果：
\begin{verbatim}
1 0
1 5
\end{verbatim}


\subsubsection{continue命令}
continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。

例如，对上面的例子进行修改：
\begin{lstlisting}[language=sh]
#!/bin/bash
while :
do
    echo -n "Input a number between 1 to 5: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "Your number is $aNum!"
        ;;
        *) echo "You do not select a number between 1 to 5!"
            continue
            echo "Game is over!"
        ;;
    esac
done
\end{lstlisting}
运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句
\begin{lstlisting}[language=sh]
echo "Game is over!"
\end{lstlisting}
永远不会被执行。

同样，continue 后面也可以跟一个数字，表示跳出第几层循环。

再看一个 continue 的例子：
\begin{lstlisting}[language=sh]
#!/bin/bash

NUMS="1 2 3 4 5 6 7"

for NUM in $NUMS
do
   Q=`expr $NUM % 2`
   if [ $Q -eq 0 ]
   then
      echo "Number is an even number!!"
      continue
   fi
   echo "Found odd number"
done
\end{lstlisting}
运行结果：
\begin{verbatim}
Found odd number
Number is an even number!!
Found odd number
Number is an even number!!
Found odd number
Number is an even number!!
Found odd number
\end{verbatim}



\section{函数}
\subsection{函数的定义}
函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。

Shell 函数的定义格式如下：
\begin{verbatim}
function_name () {
    list of commands
    [ return value ]
}
\end{verbatim}

如果愿意，也可以在函数名前加上关键字 function：
\begin{verbatim}
function function_name () {
    list of commands
    [ return value ]
}
\end{verbatim}


\subsection{函数返回值}
函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。

Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。

如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。

先来看一个例子：
\begin{lstlisting}[language=sh]
#!/bin/bash

# Define your function here
Hello () {
   echo "Url is http://see.xidian.edu.cn/cpp/shell/"
}

# Invoke your function
Hello
\end{lstlisting}
运行结果：
\begin{verbatim}
$./test.sh
Hello World
$
\end{verbatim}


\subsection{函数参数}
在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 \$n 的形式来获取参数的值，例如，\$1表示第一个参数，\$2表示第二个参数...

带参数的函数示例：
\begin{lstlisting}[language=sh]
#!/bin/bash
funWithParam(){
    echo "The value of the first parameter is $1 !"
    echo "The value of the second parameter is $2 !"
    echo "The value of the tenth parameter is $10 !"
    echo "The value of the tenth parameter is ${10} !"
    echo "The value of the eleventh parameter is ${11} !"
    echo "The amount of the parameters is $# !"  # 参数个数
    echo "The string of the parameters is $* !"  # 传递给函数的所有参数
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
\end{lstlisting}
运行脚本：
\begin{verbatim}
The value of the first parameter is 1 !
The value of the second parameter is 2 !
The value of the tenth parameter is 10 !
The value of the tenth parameter is 34 !
The value of the eleventh parameter is 73 !
The amount of the parameters is 12 !
The string of the parameters is 1 2 3 4 5 6 7 8 9 34 73 !"
\end{verbatim}

注意，\$10 不能获取第十个参数，获取第十个参数需要\$\{10\}。当n>=10时，需要使用\$\{n\}来获取参数。

另外，还有几个特殊变量用来处理参数，前面特殊变量章节中已经提到。


\subsection{函数调用}
调用函数只需要给出函数名，不需要加括号。

再来看一个带有return语句的函数：
\begin{lstlisting}[language=sh]
#!/bin/bash
funWithReturn(){
    echo "The function is to get the sum of two numbers..."
    echo -n "Input first number: "
    read aNum
    echo -n "Input another number: "
    read anotherNum
    echo "The two numbers are $aNum and $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
# Capture value returnd by last command
ret=$?
echo "The sum of two numbers is $ret !"
\end{lstlisting}
运行结果：
\begin{verbatim}
The function is to get the sum of two numbers...
Input first number: 25
Input another number: 50
The two numbers are 25 and 50 !
The sum of two numbers is 75 !
\end{verbatim}
函数返回值在调用该函数后通过 \$? 来获得。

再来看一个函数嵌套的例子：
\begin{lstlisting}[language=sh]
#!/bin/bash

# Calling one function from another
number_one () {
   echo "Url_1 is http://see.xidian.edu.cn/cpp/shell/"
   number_two
}

number_two () {
   echo "Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/"
}

number_one
\end{lstlisting}
运行结果：
\begin{verbatim}
Url_1 is http://see.xidian.edu.cn/cpp/shell/
Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/
\end{verbatim}



\subsection{终端调用函数}
如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。






\subsection{删除函数}
像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示：
\begin{lstlisting}[language=sh]
$unset .f function_name
\end{lstlisting}


